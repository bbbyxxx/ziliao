#  Java基础

##  Java基础部分

###  Java有哪些特性，举个多态的例子

封装、继承、多态。多态：指允许不同类的对象对同一消息作出响应，即同一消息可以根据发送对象的不同而采用多种不同的行为方式。

###  为什么重写equals()还要重写hashCode() ？

HashMap中，如果要比较key是否相等，要同时使用这两个方法，因为自定义的类的hashCode()方法继承于Object类，其hashCode()为默认的内存地址，这样即便有两个相同的对象，比较也是不相等的。HashMap中先检查key的hashCode()是否相等，如果相等再equals()，若相等则认为这两个key时相等的，这样比是因为我们可以重写hashCode()值使相同的key计算的hashCode()值相同，而Object中的equals()比的就是hashcode值，所以会存在判断出错，所以需要重写再进行一次判断。(即重写hashCode()必须重写equals())重写后如果两个对象的hashCode()值不同肯定这两个对象不相同，就不必再equals()。

```java
public boolean equals(Object obj) {
  return (this == obj); //如果两个对象的引用完全相同则返回true，如果是基本类型，就比较数值是否相等
}
```

### 一个十进制的数在内存中是怎么存的？

在计算机中是以补码的形式存储的，而二进制的小数无法精确的表达10进制小数，则在计算的过程中会产生误差 。

```java
float f = 4.0 - 3.6; //0.40000001则会出现误差
```

###  Java中的八大基本类型

byte（8位）、short（16位）、int（32）、long（64）、float（单精度，32位）、double（64位）、char（16位）、boolean（1位）。在Java中万物皆对象，对象抽象类，所以会有它们的包装类，分别对应（Byte）、（Short）、（Integer）、（Long）、（Float）、（Double）、（Character）、（Boolean）。故有自动装箱和拆箱，装箱即从基本数据类型转换为对应的包装类型，反之为拆箱。

```java
Integer integer = Integer.valueOf(1);
int i = integer.intValue();
/**
int和Integer的区别？
除了上述，还有一个就是Integer默认值为null，比如当一个考生缺考，此时就应该为null，而不是为0。
*/

/**
这里需要注意缓冲池的概念，当值在-128～127之间，会从缓冲池中返回，不在这个范围，初始化时则会在堆内存中新建对象并返回引用（地址不同，即hashCode()不同，可以重写hashCode()），至于为什么设计缓冲池这里不做概述。
相应的还有
ByteCache、ShortCache、LongCache、CharacterCache
*/
```

###  Java中到底是值传递还是引用传递？

在Java中没有引用传递，因为Java舍弃了指针，所有传参方式都是值传递，如果是基本型变量，则传递的是一个副本，改变副本不改变原值，而当传入一个对象型变量时，就是一个“引用传递”，此时传递的是对象地址的一个副本，对这个地址进行操作就会同时改变原对象，就类似于两个引用指向一个对象（浅拷贝）。

###  数组(Array)和列表(ArrayList)有什么区别？

- Array可以包含基本类型和对象类型，List只能包含对象类型
- Array大小是固定的，ArrayList大小是动态变化的（ArrayList初始化容量为10，每次扩容1.5倍 10->15->22...)
- ArrayList中提供了更多的方法和特性，比如add()、addfirst()等等
- ArrayList的底层实现就是一个动态的Array

###  String、StringBuffer、StringBuilder的区别？

Java平台提供。。。存储和操作字符串，即包含多个字符的字符数据，String是不可变得，其它两个是可变，并且StringBuffer为线程安全，当如果知道字符串数据要改变的时候并且线程安全就可使用StringBuffer。当改变String时，反编译可知道new了StringBuilder对象再进行append()。扩容机制：默认为16，当需要扩容时，先检查2*当前容量+2，如果不满足，则当前容量+准备存储的长度。

```java
int newCapacity = (value.length << 1)+2;
StringBuilder(int capacity)；
/*通过上面这个构造方法，如果初始容量为0，那么<<1会一直为0，那么扩容就失去了它的本质了*/
```

###  String为什么是不可变的？

不可变是指一个对象在创建完成后它的状态不能再改变，那么这个对象就是不可变的。我们知道String是被定义为final的，所以它是不可继承，而String的内部实现是一个char数组，这个数组是private final，即外部不可访问，一旦赋值后不可再更改。

1. 字符串常量是Java堆内存中一个特殊的存储区域，当创建一个String对象时，假如此字符串值已经存在于常量池中，则不会创建一个新的对象，而是引用已经存在的对象，假如字符串对象允许改变，那么将会导致各种逻辑错误，比如改变一个对象会影响到另一个独立对象，严格来说，常量池的思想是一种优化手段，如果String为可变，那么随着Java 程序的启动，堆内存中的对象越来愈多，性能将会急速下降。
2. Java中String对象的哈希码被频繁调用（HashMap），字符串不变性保证了hashCode的唯一性，因此可以放心的进行缓存，这样就不必每次都去计算进行新的hashCode

3. String被所有的类用来当作参数，例如URL，Path等等，如果不是不可变得，将会引起各种安全隐患

###  讲一讲Java中的final关键字怎么用的？

1. 当用final修饰一个类时，表明这个类不能被继承，也就是说如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。

2. 使用final时修饰方法会把方法锁定，以防任何继承类修改它的含义。

3. 修饰变量时，如果是基本类型的变量，则其数值一旦在初始化之后便不能更改，如果是引用类型的变量，那么在对其初始化之后便不能再让其指向另一个对象。

###  重载和重写的区别，相同参数不同返回值能重载吗？

重载（OverLoading）

1. 方法重载是让类以统一的方式处理不同类型数据的一种手段，多个同名方法同时存在，具有不同的参数个数/类型。
2. 方法的重载就是在类中可以创建多个方法，具有相同的名字，但具有不同的参数和定义。
3. 重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回类型作为重载函数的区分标准。

重写（Overriding）

  父类与子类之间的多态性，对父类的函数进行重新定义，如果再子类中定义某方法与其父类有相同的名称和参数，我们就说该方法被重写。重写也叫方法覆盖。