#  Java基础

##  Java基础部分

###  面向对象和面向过程的区别

####  面向过程

1. 优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素时，采用面向过程开发
2. 缺点：没有面向对象易维护、易复用、易扩展

####  面向对象

1. 优点：易维护、易复用，可以设计出低耦合的系统，使系统更加灵活，更加易于维护
2. 缺点：性能比面向过程低

###  Java有哪些特性？

封装、继承、多态，平台无关性、可靠性、安全性、支持多线程、网络编程等。

- 继承：一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。新类可以从现有的类中派生，这个过程为类继承，新类继承了原始类的特性，新类则为原始类的派生类，原始类则为基类。
  - 子类拥有父类对象的所有的属性和方法（包括私有属性和私有方法），无权访问，仅拥有
  - 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展
  - 子类可以用自己的方式实现父类的方法（重写）
- 封装：把数据和过程包围起来，对数据的访问只能通过已定义的界面，面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其它对象。
- 多态：指允许不同类的对象对同一消息作出响应，即同一消息可以根据发送对象的不同而采用多种不同的行为方式。

###  什么是JVM？什么是字节码？

1. JVM：是运行Java字节码的虚拟机，JVM有针对不同系统的特定实现(Windows、Linux、macOS)

2. 字节码：在Java中，JVM可以理解的代码就叫做字节码(.class文件)，它不面对任何特定的处理器，只面向虚拟机。Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，并且，由于字节码并不针对一种特定的机器，因此，Java程序无须重续编译便可在多种不同操作系统的计算机上运行。

###  Java和C++的区别

- 都是面向对象的语言，支持封装、继承、多态
- Java不提供指针来直接访问内存，程序内存更加安全
- Java的类是单继承的，接口可以多继承，C++中支持多重继承
- Java有自动内存管理机制，不需要程序员手动释放无用内存

###  Java中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？

当一个对象被创建时，构造函数就会被调用，每一个类都有构造函数。在程序员没有给类提供构造函数的情况下，Java编译器会为这个类创建一个默认的构造函数。Java中构造函数重载和方法重载相似，可以为一个类创建多个构造函数。Java不支持像C++中那样的复制构造函数。

###  为什么重写equals()还要重写hashCode() ？

HashMap中，如果要比较key是否相等，要同时使用这两个方法，因为自定义的类的hashCode()方法继承于Object类，其hashCode()为默认的内存地址，这样即便有两个相同的对象，比较也是不相等的。HashMap中先检查key的hashCode()是否相等，如果相等再equals()，若相等则认为这两个key时相等的，这样比是因为我们可以重写hashCode()值使相同的key计算的hashCode()值相同，而Object中的equals()比的就是hashcode值，所以会存在判断出错，所以需要重写再进行一次判断。(即重写hashCode()必须重写equals())重写后如果两个对象的hashCode()值不同肯定这两个对象不相同，就不必再equals()。

- 相等的对象必须具有相同的哈希码
- 如果两个对象的hashCode相同，它们并不一定相等

```java
public boolean equals(Object obj) {
  return (this == obj); //如果两个对象的引用完全相同则返回true，如果是基本类型，就比较数值是否相等
}
```

### 一个十进制的数在内存中是怎么存的？

在计算机中是以补码的形式存储的，而二进制的小数无法精确的表达10进制小数，则在计算的过程中会产生误差 。

```java
float f = 4.0 - 3.6; //0.40000001则会出现误差
```

###  Java中的八大基本类型

byte（8位）、short（16位）、int（32）、long（64）、float（单精度，32位）、double（64位）、char（16位）、boolean（1位）。在Java中万物皆对象，对象抽象类，所以会有它们的包装类，分别对应（Byte）、（Short）、（Integer）、（Long）、（Float）、（Double）、（Character）、（Boolean）。故有自动装箱和拆箱，装箱即从基本数据类型转换为对应的包装类型，反之为拆箱。

```java
Integer integer = Integer.valueOf(1);
int i = integer.intValue();
/**
int和Integer的区别？
除了上述，还有一个就是Integer默认值为null，比如当一个考生缺考，此时就应该为null，而不是为0。
*/

/**
这里需要注意缓冲池的概念，当值在-128～127之间，会从缓冲池中返回，不在这个范围，初始化时则会在堆内存中新建对象并返回引用（地址不同，即hashCode()不同，可以重写hashCode()），至于为什么设计缓冲池这里不做概述。
相应的还有
ByteCache、ShortCache、LongCache、CharacterCache
*/
```

###  Java中到底是值传递还是引用传递？

在Java中没有引用传递，因为Java舍弃了指针，所有传参方式都是值传递，如果是基本型变量，则传递的是一个副本，改变副本不改变原值，而当传入一个对象型变量时，就是一个“引用传递”，此时传递的是对象地址的一个副本，对这个地址进行操作就会同时改变原对象，就类似于两个引用指向一个对象（浅拷贝）。

###  数组(Array)和列表(ArrayList)有什么区别？

- Array可以包含基本类型和对象类型，List只能包含对象类型
- Array大小是固定的，ArrayList大小是动态变化的（ArrayList初始化容量为10，每次扩容1.5倍 10->15->22...)
- ArrayList中提供了更多的方法和特性，比如add()、addfirst()等等
- ArrayList的底层实现就是一个动态的Array

###  String、StringBuffer、StringBuilder的区别？

Java平台提供。。。存储和操作字符串，即包含多个字符的字符数据，String是不可变得，其它两个是可变，并且StringBuffer为线程安全，当如果知道字符串数据要改变的时候并且线程安全就可使用StringBuffer。当改变String时，反编译可知道new了StringBuilder对象再进行append()。扩容机制：默认为16，当需要扩容时，先检查2*当前容量+2，如果不满足，则当前容量+准备存储的长度。

```java
int newCapacity = (value.length << 1)+2;
StringBuilder(int capacity)；
/*通过上面这个构造方法，如果初始容量为0，那么<<1会一直为0，那么扩容就失去了它的本质了*/
```

###  String为什么是不可变的？

不可变是指一个对象在创建完成后它的状态不能再改变，那么这个对象就是不可变的。我们知道String是被定义为final的，所以它是不可继承，而String的内部实现是一个char数组，这个数组是private final，即外部不可访问，一旦赋值后不可再更改。

1. 字符串常量是Java堆内存中一个特殊的存储区域，当创建一个String对象时，假如此字符串值已经存在于常量池中，则不会创建一个新的对象，而是引用已经存在的对象，假如字符串对象允许改变，那么将会导致各种逻辑错误，比如改变一个对象会影响到另一个独立对象，严格来说，常量池的思想是一种优化手段，如果String为可变，那么随着Java 程序的启动，堆内存中的对象越来愈多，性能将会急速下降。
2. Java中String对象的哈希码被频繁调用（HashMap），字符串不变性保证了hashCode的唯一性，因此可以放心的进行缓存，这样就不必每次都去计算进行新的hashCode

3. String被所有的类用来当作参数，例如URL，Path等等，如果不是不可变得，将会引起各种安全隐患

###  讲一讲Java中的final关键字怎么用的？

1. 当用final修饰一个类时，表明这个类不能被继承，也就是说如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。

2. 使用final时修饰方法会把方法锁定，以防任何继承类修改它的含义。

3. 修饰变量时，如果是基本类型的变量，则其数值一旦在初始化之后便不能更改，如果是引用类型的变量，那么在对其初始化之后便不能再让其指向另一个对象。

###  重载和重写的区别，相同参数不同返回值能重载吗？

重载（OverLoading）

1. 方法重载是让类以统一的方式处理不同类型数据的一种手段，多个同名方法同时存在，具有不同的参数个数/类型。
2. 方法的重载就是在类中可以创建多个方法，具有相同的名字，但具有不同的参数和定义。
3. 重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回类型作为重载函数的区分标准。

重写（Overriding）

  父类与子类之间的多态性，对父类的函数进行重新定义，如果再子类中定义某方法与其父类有相同的名称和参数，我们就说该方法被重写。重写也叫方法覆盖。

###  static关键字是什么意思？Java中是否可以覆盖一个private或者是static的方法？

static关键字表明一个成员变量或者是成员方法可以在不需要一个实例变量的情况下被访问。Java中private方法被继承后但是不能被访问，所以不能覆盖；方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的，static方法跟类的实例不相关，所以概念上不适用。

###  什么是泛型？

1. 定义：即“参数化类型”，也就是说操作的数据类型被指定为一个参数。

2. 好处：类型安全，提供编译期间的类型检测；前后兼容；泛化代码，代码可以更多的重复利用；消除强制类型转换
3. 类型擦除：通过类型参数合并，将泛型类型实例关联到同一份字节码上，编译器只为泛型类生成一份字节码，并将其实例关联到字节码上，类型擦除的关键在于从泛型类型中清除类型参数的相关信息，并且在必要的时候添加类型检查和类型转换的方法。

###  如何通过反射创建对象？

1. 通过类对象调用newInstance()方法，例如：String.class.newInstance()
2. 通过类对象的getConstructor()或getDeclaredConstructor()获得构造器 String.class.getConstructor(String.class).newInstance("Hello");

###  接口和抽象类的区别

- 抽象类可以有构造方法，接口中不能有构造方法
- 抽象类中可以有普通成员变量，接口中不能有普通成员变量，默认为public static final
- 抽象类中可以包含非抽象的普通方法，接口中的所有方法必须是抽象的
- 抽象类中的抽象方法的访问类型可以是public、protected和default，接口中的方法默认为public abstract
- 抽象类中可以包含静态方法，接口中不能
- 一个类可以实现多个接口，但只能继承一个抽象类

###  在Java中定义一个空构造的作用

Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会默认调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为在父类找不到没有参数的构造方法可供执行，解决方法就是在父类里加上一个不做事且没有参数的构造方法。

###  finla、finally、finalize的区别

- final用于声明属性、方法和类，表示属性不可变，方法不可覆盖，类不可继承
- finally是异常处理语句结构的一部分，表示总是执行
- finalize是Object类中的一个方法，在垃圾收集器执行的时候会调用被回收的此方法，可以覆盖此方法提供垃圾收集时的其它资源回收（尽量不要覆盖）

###  Java语言如何进行异常处理？关键字分别代表什么意义？

Java通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java 中，每个异常都是一个对象，是Throwable类或其它子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常对象，调用这个对象的方法可以捕获到这个异常并进行处理。

用try执行一段程序，如果出现异常，系统会抛出一个异常，这时你可以通过它的类型来catch它，或finally由缺省处理器来处理。throws用来标明一个成员函数可能抛出的各种异常，throw用来明确地抛出一个异常。

###  ArrayList和LinkedList的区别，如果一直在ArrayList的尾部添加元素，用哪个效率高？

ArrayList是采用数组实现的，查找效率比LinkedList高，LinkedList采用双向循环链表实现，插入和删除的效率比ArrayList高。

###  红黑树

- 每个节点要么是红色，要么是黑色
- 根结点永远是黑色
- 所有的叶子结点都是黑色
- 每个红色节点的两个子节点都是黑色
- 从任一节点到其子树中的叶子节点的路径都包含相同数量的黑色节点

###  ConcurrentHashMap工作原理、1.7和1.8的区别？

####  工作原理

ConcurrentHashMap为了提高本身的并发能力，在内部采用了一个叫做Segment的结构，一个Segment其实就是一个类HashTable的结构，Segment内部维护了一个链表数组，ConcurrentHashMap定位一个元素的过需要两次Hash操作，第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部，因此，带来的副作用是Hash的过程比普通的HashMap要长，好处是写操作的时候可以只对元素所在的Segment进行操作即可，不会影响到其它的Segment，这样，在理想的情况下，ConcurrentHashMap可以最高同时支持Segment数量大小的写操作，所以可以大大提高ConcurrentHashMap的并发能力。

####  区别

1.7之前采用的是锁机制，在对某个Segment进行操作时，将该Segment锁定，不允许对其进行非查询操作，而在1.8之后采用Node + CAS + Synchronized无锁算法， 进行了良好的优化。

###  Collection和Collections的区别

Collection是集合类的上层接口，继承与它的接口主要有Set和List。它拥有基础的方法（add、addAll、remove、removeAll、iterator、

Collections是针对集合类的一个帮助类，它提供如下三类方法：

- 让集合不可变，当增删改的时候会报异常；
- 给集合加上锁，即方法上锁，安全但是效率低；
- 各种通用方法，二分查找、排序、逆序、打乱等等。

###  Java中的异常

Throwable是所有异常的父类，它有两个直接的子对象，分别是Error和Exception。其中Error是指我们无法处理的错误，比如说虚拟机异常、虚拟机内存溢出等无法控制的错误。Exception分为编译时异常和运行时异常，编译时常见的比如说ClassNotFoundException、IOException、SQLException等，运行时异常常见的就是空指针异常、数组越界、除0等在运行时才可以发现的异常。

我们必须对编译时异常进行处理，否则程序无法运行。但对运行时异常可以不处理，那么出现运行时异常后要么是线程终止，要么是主程序终止，如果不想终止，则必须捕捉所有的运行时异常

###  ArrayList

ArrayList是一个动态数组，因为它可以动态的扩充自己的容量，这个容量我们是看不见的，但是可以通过反射来进行访问。ArrayList的初始容量是10，扩容因子是1.5，也就是10->15->22->33，当第十一个元素插入时会进行扩容，底层是一个elementData数组，类型为Object。

如果初始容量定义为0，则返回一个空的elementData，当第一次add元素时会进行扩容，它的扩容就是一次拷贝，即Arrays.copyOf() /*即对数组进行拷贝*/，会消耗资源，所以尽量在初始化的时候就预计好容量以防资源浪费。ArrayList的删除和增加都是先检查插入或者删除的位置是否越界，越界了就抛出异常，插入会检查是否需要扩容，然后进行相关操作。

###  LinkedList

LinkedList是一个双向循环链表，有三个主要的属性，size、first和last，size即为链表当前有多少个节点，first为它的头节点（不放数据），last为尾节点。

add(index，element）先检查index是否越界，再检查index是否等于size，如果等于，就调用add(e) ，然后new一个节点，将新节点索引到index位置处的节点，把index节点添加到new节点的后面。

get首先判断是否越界，因为它有头节点和尾节点，所以会判断是从头节点开始遍历还是从尾节点开始遍历，判断方法是用index和size/2比，如果小于的话从first遍历，否则从last开始遍历。

##  Java高级部分

###  线程和进程的区别

- 线程作为任务调度和执行的基本单位，进程作为资源分配的基本单位
- 不仅进程可以并发，线程也可以并发
- 线程不拥有资源，线程可访问进程的资源
- 进程之间切换资源较大，线程直接切换较小

###  多线程中的i++线程安全吗？为什么？

不安全。i++不是原子性操作，i++分为取值、加1、再赋值，执行期中任何一步都是有可能被其他线程抢占的。

###  Java中有几种线程池

1. newFixedThreadPool：创建一个指定工作线程数量的线程池，每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将刚提交的任务存入到池队列中。
2. newCachedThreadPool：创建一个可根据实际情况调整线程数量的线程池。线程池的线程数量不稳定，但若有空闲线程可以复用，则会优先使用可服用的线程。若所有线程都在工作，又有新的任务提交，则会创建新的线程处理任务，所有线程在当前任务执行完毕后，将返回线程池进行复用。
3. newSingleThreadPool：创建只有一个线程的线程池。
4. newScheduleThreadPool：创建一个定长的线程池，而且支持定时的以及周期性的任务执行。

###  线程池有什么好处

- 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
- 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能执行。
- 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以统一分配、调优和监控。

###  线程的所有状态

```java
public enum State {
  NEW,             //刚刚创建的线程，还没开始执行
  RUNNABLE,        //当调用start方法时，线程开始执行 
  BLOCKED,         //遇到了synchronized同步块
  WAITING,         //无时间限制的等待
  TIMED_WAITING,   //有时限的等待
  TERMINATED;      //线程执行完成
}
```

![线程状态](/Users/a/Desktop/Java-victor/images/线程状态.png)

###  如何保证线程安全

通过合理的时间调度，避开贡献资源的存取冲突。另外，在并行任务设计上可以通过适当的策略，保证任务与任务之间不存在共享资源，设计一个规则来保证客户的计算工作和数据访问只会被一个线程或一台工作机完成，而不是把一个客户的计算工作分配给多个线程去完成。

###  简述synchronized和java.util.concurrent.locks.lock的异同

相同点：lock能完成synchronized所实现的所有功能

不同点：lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而lock一定要求程序员手工释放。

### 反射的实现与作用

Java语言编译后会生成一个.class文件，反射就是通过字节码文件找到某一个类，类中的方法以及属性等。反射的实现主要借助以下四个类：

- Class：类的对象
- Constructor：类的构造方法
- Field：类中的属性对象
- Method：类中的方法对象

作用：反射机制指的是程序在运行时能够获取自身的信息。在Java中，只要给定类的名字，那么就可以通过反射机制来获取累的所有信息。

### 负载均衡算法

- 随机

  ```java
  public class Server {
      public List<String> list = new ArrayList<String>() {
          {
              add("192.168.0.1");
              add("192.168.0.2");
              add("192.168.0.3");
              add("192.168.0.4");
          }
      };
  }
  ```

  ```java
  public class FullRandom {
      static Server server = new Server();
      static Random random = new Random();
      static int[] array = new int[4];
  
      public static int[] go() {
          int number = random.nextInt(server.list.size());
          array[number]++;
          return array;
      }
      public static void main(String[] args) {
          for (int i = 0; i < 1000; i++) {
              go();
          }
          for (int i = 0; i < array.length; i++) {
              System.out.println("192.168.0." +(i+1) + ":" + array[i]);
          }
      }
  }
  ```

- 加权随机

  ```java
  public class Server {
      public HashMap<String,Integer> map = new HashMap<String,Integer>(){
          {
              put("192.168.0.1",2);
              put("192.168.0.2",9);
              put("192.168.0.3",3);
              put("192.168.0.4",15);
          }
      };
  }
  ```

  ```java
  public class RandomWeight {
      static Server server = new Server();
      static Random random = new Random();
  
      public static String go() {
          int weight_sum = server.map.values().stream().mapToInt(a -> a).sum();
          int number = random.nextInt(weight_sum);
          for (Map.Entry<String,Integer> item : server.map.entrySet()) {
              if (item.getValue() > number) {
                  return item.getKey();
              }
              number -= item.getValue();
          }
          return "";
      }
  
      public static void main(String[] args) {
          for (int i = 0; i < 10; i++) {
              System.out.println(go());
          }
      }
  }
  
  ```

  

- 轮询：完全轮询、加权轮询、平滑加权轮询。

- 完全轮询

  ```java
  //Server参考 随机算法。
  public class FullRound {
      static Server server = new Server();
      static int index;
  
      /**
       * 1->2->3->4->1->2....
       * @return
       */
      public static String go() {
          if (index == server.list.size()) {
              index = 0;
          }
          return server.list.get(index++);
      }
  
      public static void main(String[] args) {
          for (int i = 0; i < 10; i++) {
              System.out.println(go());
          }
      }
  }
  
  ```

- 加权轮询

  ```java
  //Server参考 加权随机算法。
  public class RoundWeight {
      static Server server = new Server();
      static int index;
  
      public static String go() {
          int sum_weight = server.map.values().stream().mapToInt((a -> a)).sum();
          int number = (index++) % sum_weight;
          for (Map.Entry<String,Integer> item : server.map.entrySet()) {
              if (item.getValue() > number) {
                  return item.getKey();
              }
              number -= item.getValue();
          }
          return "";
      }
  
      public static void main(String[] args) {
          int[] array = {0,0,0,0};
          for (int i = 0; i < 10000; i++) {
              switch (go()) {
                  case "192.168.0.1" : array[0]++; break;
                  case "192.168.0.2" : array[1]++; break;
                  case "192.168.0.3" : array[2]++; break;
                  case "192.168.0.4" : array[3]++; break;
              }
          }
          for (int i = 0; i < array.length; i++) {
              System.out.println("192.168.0." + (i+1) + "\t" + array[i]);
          }
      }
  }
  //观察大概率会导致一个或多个服务器的压力突然上升，有一个或者几个压力极小。
  ```

- 原地址散列

  ```java
  public class Hash {
      public static String go(String client) {
          int count = 20;
          TreeMap<Integer,String> treeMap = new TreeMap<Integer,String>();
          for (String s : new Server().list) {
              for (int i = 0; i < count; i++) {
                  treeMap.put((s + "--服务器--" + i).hashCode() , s);
              }
          }
          int clientHash = client.hashCode();
          SortedMap<Integer,String> sortedMap = treeMap.tailMap(clientHash);
          Integer firstHash;
          if (sortedMap.size() > 0) {
              firstHash = sortedMap.firstKey();
          }else {
              firstHash = treeMap.firstKey();
          }
          String s = treeMap.get(firstHash);
          return s;
      }
  
      public static void main(String[] args) {
          System.out.println(go("为啥要吃蝙蝠？"));
          System.out.println(go("为什么"));
          System.out.println(go("0"));
          System.out.println(go("-110000"));
          System.out.println(go("风雨交加"));
      }
  }
  
  ```

  

##  JVM

下面将主要针对HotSpot VM，HotSpot是JVM规范的一种实现，是目前使用范围最广的Java虚拟机。

###  JVM5大内存

根据JVM规范，JVM内存共分为虚拟机栈、堆、方法区、程序计数器、本地方法栈五个部分。

####  虚拟机栈

线程私有，每个方法在执行的时候会创建一个栈帧，存储了局部变量表、操作数栈、动态链接、方法返回地址等；每个方法从调用到执行完毕，对应一个栈帧在虚拟机栈中的入栈和出栈。

####  堆

线程共享，被所有线程共享的一块内存区域，在虚拟机启动时创建，用于存放对象实例。

####  方法区

线程共享，被所有线程共享的一块内存区域；用于存储已被虚拟机加载的类信息、常量、静态变量等。

####  程序计数器

线程私有，是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有”的内存。

####  本地方法栈（C栈）

线程私有，主要为虚拟机使用到的Native方法服务。

###  JVM的堆内存分配

JVM的堆内存分为新生代和老年代。新生代 ：旧生代 = 1 ：2，新生代存储的都是新创建的比较小的对象，而老年代存的都是比较大的、活的久的对象，所以老年代占JVM堆内存较大。

新生代又分为Eden区和Survivor区。Eden区 ：Survivor区 = 8  ：1 : 1，Survivor中存储的是GC之后幸存的对象，实际上只有很少一部分会幸存，所以占比例较小。

###  对象的内存布局

在HotSpot虚拟机中，对象的内存布局分为对象头(Header)、实例数据(Instance Data)、对齐填充(Padding).

- 对象头记录了对象在运行过程中所需要使用的一些数据：哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID等，对象头可能包含类型指针，通过该指针能确定对象属于哪个类，如果对象是一个数组，那么对象头还会包括数组长度。
- 实例数据：实例数据部分就是成员变量的值，其中包括父类成员变量和本类成员变量。
- 对齐填充：用于确保对象的总长度为8字节的整数倍。HotSpotVM的自动内存管理系统要求对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数，因此，当对象实例数据部分没有对其时，就需要通过对齐填充来补全。

###  JVM回收算法

####  标记-清除算法

将垃圾回收分为两个阶段：标记阶段和清除阶段。在标记阶段首先标记出所有需要回收的对象（可达性分析），在标记完成后统一清理掉所有被标记的对象。

存在两个问题：

- 效率问题：标记和清除效率不高。
- 空间问题：标记清除后产生大量不连续的内存碎片，空间碎片太多可能会导致在运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集。

####  复制算法

该算法的核心是将可用内存按容量划分为大小相等的两块，每次只用其中一块，当这一块的内存用完，就将还存活的对象（非垃圾）复制到另外一块上，然后把已使用过的内存空间一次清理掉。

优点：不用考虑碎片问题，方法简单高效。

缺点：内存浪费严重。

####  标记-整理算法

标记-清除算法会产生内存碎片的问题，而复制算法需要有额外的内存担保空间，于是针对老年代的特点，又有了标记-整理算法，标记-整理算法标记过程与标记-清除算法相同，但是后续不再对可回收对象直接清理，而是让所有存活的对象都向一端移动，然后清理掉边界以外的内存。

###  可达性算法中，哪些对象可以作为GC Roots对象

- 虚拟机栈中引用的对象
- 方法区静态成员引用的对象
- 方法区常量引用的对象
- 本地方法栈JNI引用的对象

###  什么时候进行Minor GC和Full GC

Minor GC：当Eden区满时

Full GC

- 调用System.gc时，系统建议执行Full GC，但是不会一定执行
- 老年代空间不足
- 方法区空间不足
- 通过Minor GC后进入老年代的平均大小大于老年代的剩余空间
- 堆中分配很大的对象，而老年代没有足够的空间

###  回收方法区内存

方法区中存放生命周期较长的类信息、常量、静态变量，每次垃圾收集只有少量的垃圾被清除。方法区中主要清除两种垃圾：废弃常量和无用的类。

1. 判定废弃常量
   只要常量池中的常量不被任何变量或对象引用，那么这些常量就会被清除掉。比如，一个字符串“bingo”进入了常量池，但是当前系统没有任何一个String对象引用“bingo”常量，必要的话，该常量就会被清理出常量池。
2. 无用的类
   - 该类的所有对象都已经被清除
   - 加载该类的ClassLoader已经被回收
   - 该类的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

###  垃圾收集器

- Serial收集器是HotSpot运行在Client模式下的默认新生代收集器，它在进行垃圾收集时，会暂停所有的工作进程（Stop The World），用一个线程去完成GC工作。特点：简单高效，适合JVM管理内存不大的情况下（10M～100M）
- Parnew收集器其实是Serial的多线程版本，回收策略完全一样，但是又有着不同；Parnew时多线程gc收集，配合多核心的cpu效果更好。
- G1收集器时面向服务端应用的垃圾收集器，没有新生代和老年代的概念，而是将堆划分为一块块独立的Region。当要进行垃圾收集时，首先估计每个Region中垃圾的数量，每次都从垃圾回收价值最大的Region开始回收，因此可以获得最大的回收效率。 每个Region都有一个Remembered Set，用于记录本区域中所有对象引用的对象所在的区域，进行可达性分析时，在GC Roots中加上Rememered Set就可防止对整个堆内存进行遍历。

###  内存申请过程

- JVM会试图为相关Java对象在年轻代Eden区中初始化一块内存区域。
- 当Eden区空间足够时，内存申请结束，否则执行下一步。
- JVM试图释放在Eden区中所有不活跃的对象（YoungGC），释放后若Eden空间仍然不足以放入新对象，JVM则试图将部分Eden区中活跃对象放入Survivor区。
- Survivor区被用来作为Eden区及年老代的中间交换区域。当年老代空间足够时，Survivor区中存活了一定次数的对象会被移动到年老代。
- 当年老代空间不足时，JVM会在年老代进行完全的垃圾回收（Full GC）。
- Full GC后，若Survivor区及年老代仍然无法存放从Eden区复制过来的对象，则会导致JVM无法在Eden区为新生成的对象申请内存，即“OOM”。

###  OOM出现的原因

1. 年老代溢出
   - 设置的内存参数过小或程序的内存泄漏及使用不当问题
   - 循环上万次的字符串处理
   - 创建千万个对象
   - 在一段代码哪申请上百M或者上G的内存
2. 持久代溢出
   通常由于持久代设置过小，动态加载了大量Java类而导致溢出。

###  优化JVM

优化JVM一定要抓住两点。第一，怎样缩短单次GC的时间；第二，怎样缩短GC频率

**将新对象预留在年轻代**

   众所周知，由于FullGC的成本远远高于Minor GC，因此某些情况下需要尽可能将对象分配在年轻代，这在很多情况下是一个明智的选择。虽然在大部分情况下，JVM会尝试在Eden区分配对象，但是由于空间紧张等问题，很可能不得不将部分年轻对象提前向年老代压缩。因此，在JVM参数调优时可以为应用程序分配一个合理的年轻代空间，以最大限度避免新对象直接进入老年代的情况发生。 

**让大对象进入年老代**

我们在大部分情况下都会选择将对象分配在年轻代。但是，对于占用内存较多的大对象而言，它的选择可能就不是这样的。因为大对象出现在年轻代很可能扰乱年轻代GC，并破坏年轻代原有的对象结构。因为尝试在年轻代分配大对象，很可能导致空间不足，为了有足够的空间容纳大对象，JVM不得不将年轻代中的年轻对象挪到年老代。因为大对象占用空间多，所以可能需要移动大量小的年轻对象进入年老代，这对GC相对不利。基于以上原因，可以将大对象直接分配到年老代，保持年轻对象结构的完整性，这样可以提高GC的效率。如果一个大对象同时又是一个短命的对象，假设这种情况出现很频繁，那对于GC来说会是一场灾难。原本应该用于存放永久对象的年老代，被短命的对象塞满，这也意味着对堆空间进行了洗牌，扰乱了分代内存回收的基本思路。因此，在软件开发过程中，应该尽可能避免使用短命的大对象。

###  内存泄漏和内存分类

####  内存泄漏（Memory Leak）

程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。

####  内存溢出（Out Of Memory）

程序在申请内存时，没有足够的内存供申请者使用，或者说给了一个存储int类型数据的空间，但实际存储龙类型的数据，结果就是内存不够用，此时就会报错OOM，即内存溢出。

####  关系

- 内存泄漏的堆积会导致内存溢出。
- 内存溢出就是要的内存空间超出了系统实际分配的空间，此时无法满足需求，就会报错OOM。
- 内存泄漏是指向系统申请资源用完后不归还，自己也不能访问，系统也不能将它分配给需要的程序。
- 分配的内存不足以放下数据项序列，称为内存溢出。

####  内存溢出的原因

- 内存中加载的数据量过于庞大，如一次从数据库中取出大量数据。
- 集合类中有对对象的引用，使用完后未清空，使得JVM不能回收。
- 代码中存在死循环或循环产生过多重复的对象实体。
- 启动参数内存值设定的过小。

####  解决方案

- 修改JVM启动参数，直接增加内存
- 检查错误日志，查看“OOM”错误前是否有其它异常或错误
- 对代码进行分析，找出可能发出内存溢出的位置
- 重点排查：
  1. 检查对数据库查询中，是否有一次获得全部数据的查询，查询尽量采用分页的方式。
  2. 检查代码中是否有死循环或递归调用。
  3. 检查代码中是否有大循环重复产生新对象实体。
  4. 检查集合对象使用完后是否有未清楚的问题。
  5. 使用jconsole、jvisualvm动态查看内存使用情况。

###  什么是类的加载

类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class 对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。

###  类加载器

![类加载器](/Users/a/Desktop/Java-victor/images/类加载器.png)

- 启动类加载器：Bootstrap ClassLoader，负责加载存放在jdk/jre/lib（jdk代表jdk的安装目录，下同）下，如r t.jar，或被Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库。
- 扩展类加载器：Extension ClassLoader，负载加载jdk/jre/lib/ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库，开发者可以直接使用扩展类加载器。
- 应用程序类加载器：Application ClassLoader，负责加载用户类路径所指定的类，开发者可以直接使用。
- 自定义类加载器：用户自定义的类加载器

###  双亲委派模型

####  什么是双亲委派模型

是描述类加载器之间的层次关系，它要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。（父子关系一般不会以继承的关系实现，而是以组合关系来复用父加载器的代码）

####  工作过程

如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给自己的父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只要当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。

####  为什么使用双亲委派模型

像java.lang.Object这些存放在rt.jar中的类，无论使用哪个类加载器加载，最终都会委派给最顶端的启动类加载器加载，从而使得不同加载器加载的Object类都是同一个。想法，如果没有双亲委派模型，由各个类加载器自行去加载的话，如果用户编写了一个java.lang.Object的类，并放在classpath下，那么系统将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证。

###  类加载的过程

分为加载、验证、准备、解析、初始化。

####  加载：双亲委派模型

- 通过类的全限定名获取该类的二进制字节流。
- 将二进制字节流所代表的静态结构转化为方法区的运行时数据结构。
- 在内存中创建一个代表该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

#### 验证

验证阶段确保Class文件的字节流中包括的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

#### 准备

准备阶段是正式为类变量分配内存并设置初始值的阶段，这些变量所使用的内存都在方法区中进行分配。初始值通常为数据类型的默认值，假设一个类变量的定义为:

```java
private static int value = 123;
```

那么变量value在准备阶段过后的初始值为0而不是123，因为这时候尚未执行任何Java方法。但如果由final修饰，就会直接赋值为123。

####   解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

####  初始化

类初始化阶段是类加载的最后一步，是执行类构造器<clinit> () 方法的过程。

<client> () 方法是由编译器自动收集类中的所有变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的。

###  实例化过程

1. JVM会去读取指定路径下的Person.class文件，并加载进内存
2. 会先加载Person的父类（如果有直接父类的情况下）
3. 在堆内存中开辟地址，分配空间
4. 并在对象空间中，对对象的属性进行默认初始化
5. 调用对应的构造函数，进行初始化
6. 在构造函数中，第一行会先调用父类中的构造函数进行初始化
7. 父类初始化完毕后，再对子类的属性，进行显示初始化
8. 指定构造函数的特定初始化
9. 初始化完毕后，将堆内存中的地址值赋给引用变量

##  topK问题

1. 全部排序，在筛选前10000个，假设用快排，时间复杂度为O(nlogn)，但内存需要400M（4B*1000000000），方法不高效。
2. 局部淘汰法，保存前10000个数，将剩余的所有数字与当前最小数字比，如果后续都比10000个小，那么这10000个数就是最大的。若大于，则进行替换，重新找最小。（O(n+m2) ，n为99990000，m为10000)
3. 分治法，将一亿个数组分成100份，每份100万个数据。找出最大的，然后在剩下的100x10000中找出最大的10000个。问题分割成从100万中找出最大的10000个，以此类推。内存空间需要100万 * 4 = 4M，一共需要101次。
4. hash法，通过hash进行去重，然后通过分治或者最小堆的方法，最小堆可以参考局部淘汰，空间复杂度(1000)，时间复杂度nmlogm （m为10000)

如果是单机+单核+足够大内存

直接排序，顺序遍历。或者通过HashMap求出每个词的频率。

单机+多核+足够大内存

用hash将数据分为c * n个区，考虑到线程的处理速度不同，当处理速度快的线程执行完后会继续执行，直至处理完成，最后一个线程将结果合并。

单机+单核+受限内存

采用hash(x) % M，将原文件中的数据切割成M个文件，如果小文件仍大于内存，继续hash，然后放到内存处理。

