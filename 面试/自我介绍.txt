我叫雒凯，来自陕西省咸阳市，目前就读于西安科技大学通信与信息工程学院物联网工程系大三，在校期间积极参加学校和学院的活动，并获取优秀学生干部称号，有较强的求知欲自从大一接触了高级语言C语言后就开始喜欢上编程，在课余时间通过看书，看博客，看视频自学了Java及相关技术。现在就是想找一个实习锻炼自己的能力，通过实习希望能提高自己的技术水平，开阔眼界，主要还是为了毕业找个好工作做准备

一个是用户模块，一个是秒杀模块，是因为这两个的话挑战性更高。用户的登陆与注册可以说是非常重要的，1.尤其是用户的登陆，用户登录时要验证身份并且生成token写入cookie，并且写入cookie的一个过期时间，以便在用户做下一次操作时判断用户的身份和权限，注册的话会对用户输入的密码进行一个判断，必须同时有大小写和数字，长度大于等于8，简单的密码形同虚设，很容易被破解。注册的时候并且会提示用户选择密保，以便后续找回密码。或者说绑定自己的一个邮箱，如果条件可能的话就往他的邮箱发送链接，用户点击完成后，才能注册成功。  2.密码存储的时候先在客户端有一个固定的字符串来拼接到用户的密码上，再进行md5加密，然后对加密后的字符串生成一个固定长度为15的字符串（salt），并写入到数据库中。虽然过程比较繁琐，但是安全性得到了比较高的保障。   3.为了避免用户信息被泄漏，同时也是为了避免不断的查询数据库验证密码的正确性增加系统的资源消耗，增加了验证码的一个功能，我的设计是会有一个计数器，来进行计数，当他输错密码超过三次，我就要求用户来输入验证码，超过五次之后我就会把这个用户的状态进行一个冻结。冻结半天时间，如果绑定邮箱的前提下会给用户发送邮箱通知。  4.找回密码的话会验证用户的密保问题，如果支持邮件会向注册的邮箱发送邮件，让用户通过这个链接地址访问密码重置页面来重置    5.向redis里写入用户的登陆信息的时候，会通过每个模块的不同生成不同的prefix，然后再用该prefix和token生成key，value即为bean转化为String，并且会在redis中设置过期时间，这个过期时间会和cookie头部的maxAge一致。从redis中读取的时候会将String转换为bean，方便程序调用    6.用户在注册的时候会给他一个注册时间，并且会更新登陆次数，这个登陆次数的设计主要是为了筛选出常用和不常用的用户，然后会在redis定期的清除用户token，使用js监听用户的一个关闭事件，每当用户关闭窗口，我就会对redis进行一个key清除，当然是针对性的，而不是scan，否则会导致redis卡顿。  使用了observer模式和singleton模式，observer：当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。observer主要在限流的时候使用，当点击次数达到阈值后通知我的后台对该用户账号进行一个冻结，singleton主要是在redisservice里，只会返回一个jedis实例来对redis进行操作，避免了频繁的创建和销毁所带来的代价。


秒杀模块考虑到两个问题，一个是高并发，一个是超卖。   1.采用redis作为缓存，将我的商品列表加入缓存中，还有浏览器缓存，并且尽可能的将所有的静态资源静态化，尽可能减少DB的压力，提升系统的并发。还对接口做了个限流，假设某一个用户连续点3秒内连续点10次，我就会对他进行一个限制，就会要求用户输入验证码，这里的统计采用redis里的过期函数，从第一次点击时进行设置，过期时间为3秒，快过期时进行一个判断。  2.超卖的问题根源就在于减库存操作。(select -> insert -> update )有三种方案 a.将数据从DB移到redis，所有的写操作放到内存中，并且redis的读和写性能都远高于DB，这就解决了高并发的性能问题，然后再通过异步写入到DB。在redis中维护一个队列，处理完一个就从队列中删除一个，但是存在一种线程就是一瞬间会把我的队列塞满，导致系统异常，或者队列内存非常大。但是对于处理请求进入队列的速度根本无法和涌入队列中的数目相比。   3.如果不加中间件，从性能来收，要么就是IO瓶颈，要么就是CPU瓶颈，他们都会导致数据库的活跃连接数增加，然后达到数据库的一个阈值，此时就要用数据库连接池来进行复用，因为应用程序和数据库连接要建立tcpip连接，验证身份，一次sql查询完成后再断开连接，IO瓶颈可以通过分库垂直分表解决，CPU瓶颈的话可以通过SQL调优、加索引、慢查询日志、水平分表来解决。 （垂直分割就是说将表中长的字段进行分割，拆分到另一张表，这张表和原表是1对1的关系， 水平拆分即将一个几亿行数据的表拆分成多个表，按照id取余的方式进行划分，查询时间大大减少，可以解决cpu问题） 或者说将数据库进行一个集群，通过nginx分发请求，平均的分发到每个库中。  然后防止超卖的话可以采用加锁的方式，性能不是很多，所以还是采用MVCC来进行一个控制。   4.最后采用了将商品库存加入到缓存中，当有请求过来就自减一，为0时就会使前端页面不可点，然后后面的所有请求直接返回失败，采用宁愿少卖，都不超卖的原则，然后mq的消费者订阅队列并且拿出秒杀请求写入订单，秒杀结束。

1.不加缓存、mq，存在的问题就是性能瓶颈，CPU  2.加缓存，缓存商品列表和静态资源来降低对DB的IO操作，在缓存中维护队列来处理请求，存在问题处理请求的速度远远小于请求涌入队列的速度，并且还需要维护队列，如果队列占用内存非常大也会导致系统宕掉  3.选用专业的mq，并且这个mq必须具有99.9%的可靠性，消息不能丢失也不能重发。


目前存在的问题是：
1.如果大量请求在缓存中没有查询到相关的数据，那么就会有段时间涌入到database中，导致database无法承受客户端的压力，导致宕机卡死等现象  使用加锁队列来应对这种问题， a.当缓存失效且有多个请求涌入加入一把令牌，只允许抢到令牌的请求去数据库里面读取数据并存入缓存，再让后续的请求从缓存中拿取数据（会有请求阻塞，从根本上没有解决）  b.手动触发请求，将缓存全部存储起来，并且设置过期时间尽量能分散开，避免同一时间所有缓存过期
2.容量问题：在使用JMeter进行压测的时候，发现server端的并发线程数上不去-->tomcat（tomcat是一种轻量级应用服务器，运行在jvm上，绑定ip地址并监听tcp端口）优化：tomcat调优、集群

职业规划：
1-2年内，增强自身的开发能力，还是要注重java基础知识，多学习项目开发经验，深入了解面向对象的思想
3-5年内，增强自身的设计能力，不仅要写的一手好代码，同时也要写一手好技术文档，能够从大局上出发，多理解业务






