#  ZooKeeper

ZooKeeper是一个开源的分布式协调服务。它是一个为分布式应用提供一致性服务的软件，分布式应用程序可以基于ZooKeeper实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列等功能。

##  CAP理论

###  Consistency：一致性

一致性是指数据在多个副本之间是否能够保持一致的特性，当系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处于一致的状态。

如果能够做到针对一个数据项的更新操作执行完成后，所有的用户都可以读取到其最新的值，那么这样的系统就被认为具有强一致性。

###  Availablility：可用性

可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。

”有限的时间内“是指，对于用户的一个操作请求，系统必须能够在指定的时间内返回对应的处理结果，如果超过了这个时间范围，那么系统就被认为是不可用的。

”返回结果“要求系统在完成对用户请求的处理后，返回一个正常的响应结果。正常的响应结果通常能过明确地反映出对请求的处理结果，即成功或失败，而不是一个让用户感到困惑的返回结果。

###  Partition tolerance：分区容错性

分区容错性约束了一个分布式系统需要具有如下特性：分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。

网络分区是指在分布式系统中，不同的节点分布在不同的子网络中，由于一些特殊的原因导致这些子网络之间出现网络不连通的状况，但各个子网络的内部网络是正常的，从而导致整个系统的网络环境被切分成了若干个孤立的区域。

###  放弃CAP定理

####  放弃C

指的是放弃强一致性，保留数据的最终一致性，这样的系统无法保证数据保持实时的一致性，但是能够承诺的是，数据最终会达到一个一致的状态。具体多久能够达到数据一致取决于系统的设计，主要包括数据副本在不同节点之间的复制时间长短。

####  放弃A

一旦系统遇到网络分区或其它故障时，那么收到影响的服务需要等待一定的时间，因此在等待期间系统无法对外提供正常的服务，即不可用。

####  放弃P

可以将所有数据都放在一个分布式节点上，这样不会出现由于网络分区带来的负面影响，但同时需要注意的是，放弃P就意味着放弃了系统的可扩展性。

##  BASE理论

BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来，核心思想是即使无法做到强一致性，但每个应用都可以根据自身的业务特点，采用适当的方式来达到最终一致性。

###  Basically Available(基本可用)

基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。比如说搜索引擎正常需要在0.5秒内返回结果，但由于出现故障，响应时间达到了1～2秒。

###  Soft state(软状态)

指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的时候出现延时。

###  Eventually consistent(最终一致性)

强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态，而需要实时保证系统数据的强一致性。

##  ZooKeeper同步流程

1. Leader等待server连接
2. Follower连接Leader，将最大的zxid发送给Leader
3. Leader根据Follow的zxid确定同步点
4. 完成同步后通知Follower已经成为uptodate状态
5. Follower收到uptodate消息后，又可以重新接受client的请求进行服务了

##  ZooKeeper保证了如下分布式一致性特性

1. 顺序一致性：从同一个客户端发起的事务请求，最终将会严格地按照其发起顺序被应用到ZooKeeper中去。
2. 原子性：所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的。
3. 单一视图：无论客户端连接的是哪个ZooKeeper服务器，其看到的服务端数据模型都是一致的。
4. 可靠性：一旦服务端成功地应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会被一直保留下来。
5. 实时性：ZooKeeper保证在一定的时间段内，客户端最终一定能够从服务端上读取到最新的数据状态。

##  ZooKeeper提供了什么？

- 文件系统
  - ZooKeeper提供一共多层级的节点命名空间(znode)，与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。
  - ZooKeeper为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这种特性使得ZooKeeper不能用于存放大量的数据，每个节点的存放数据上限为1M。
- 通知机制
  - ZooKeeper允许客户端向服务端的某个Znode注册一个Watcher监听，当服务端的一些指定事件触发了这个Watcher，服务端会向指定客户端发送一个事件通知来实现分布式的通知功能，然后客户端根据Watcher通知状态和事件类型做出业务上的改变。
  - 工作机制：
    1. 客户端注册watcher
    2. 服务端处理watcher
    3. 客户端回调watcher

###  ZAB协议（ZooKeeper Atomic BroadCast）

1. ZAB协议是专门为ZooKeeper实现分布式协调功能而设计的，ZooKeeper主要是根据ZAB协议实现分布式数据一致性。
2. ZooKeeper根据ZAB协议建立了主备模型完成ZooKeeper集群中数据的同步，主备模型是指在ZooKeeper集群中，只有一台leader负责处理外部客户端的事务请求，然后leader服务器将客户端的写操作数据同步到所有的follower中。
3. ZAB的核心是在整个ZooKeeper集群中只有一个节点即leadre将客户端的写操作转化为事务（或提议proposal）。leader节点在数据写完之后，将向所有的follower节点发送数据广播请求，等待所有的follower节点反馈。在ZAB协议中，只要超过半数follower节点反馈OK，leader就会向所有的follower服务器发送commit消息。将leader节点上的数据同步到follower节点之上。
4. ZAB协议主要有两种模式，一种是消息广播模式，一种是崩溃恢复模式

####  消息广播模式

- 在ZooKeeper集群中数据副本的传递策略就是采用消息广播模式。ZooKeeper中数据副本的同步方式与二阶段提交相似但又不同。二阶段提交要求协调者必须等到所有的参与者全部反馈ACK确认消息后，再发送commit消息。要求所有的参与者要么全部成功要么全部失败，二阶段提交会产生严重阻塞的问题。
- ZAB协议中leader等待follower的ACK反馈是指“只要半数以上的follower成功反馈即可，不需要收到全部follower反馈”
- 消息广播的具体步骤：
  1. 客户端发起一个写操作请求
  2. leader服务器将客户端的request请求转化为事务proposal提案，同时为每个proposal分配一个全局唯一的ID，ZXID
  3. leader服务器与每个folloer之间都有一个队列，leader将消息发送到该队列
  4. follower机器从队列中取出消息处理完毕后，向leader服务器发送ACK确认
  5. leader服务器收到半数以上的followerACK后，即认为可以发送commit
  6. leader向所有的follower服务器发送commit消息
- ZooKeeper采用ZAB协议的核心是只要有一台服务器提交了proposal，就要确保所有的服务器最终都能正确提交proposal。
- leader服务器与每个follower之间都有一个单独的队列进行收发消息，使用队列消息可以做到异步解耦。如果使用同步方式容易引起阻塞，性能上差很多。

####  恢复模式

- ZooKeeper集群中为保证任何所有进程能够有序的进行，只能是leader服务器接受写请求，即使是follower服务器接受到客户端的请求，也会转发到leader服务器进行处理。
- 如果leader服务器发生崩溃，则ZAB协议要求ZooKeeper集群进行崩溃恢复和leader服务器选举
- ZAB协议崩溃恢复要求满足如下两个要求：
  - 确保已经被leader提交的proposal必须最终被所有的follower服务器提交
  - 确保丢弃已经被leader提出的但是没有被提交的proposal
- 新选举的leader不能包含未提交的proposal，同时，新选举的leader节点中含有最高的ZXID，这样的好处是可以避免leader服务器检查proposal的提交和丢弃工作
- leader发生崩溃时分为以下场景：
  - leader在提出proposal时未提交之前崩溃，则经过崩溃恢复之后，新选举的leader一定不能是之前的leader，因为这个leader存在未提交的proposal。
  - leader在发送commit消息之后崩溃，即消息已经发送到队列中，经过崩溃恢复之后，参与选举的follower服务器中有的节点已经消费了队列中的commit消息，则该follower节点将会被选举为最新的leader。剩下的动作就是数据同步过程



###  ZAB协议原理

- ZAB协议要求每个leader都要经历三个阶段，发现、同步、广播
- 发现：要求ZooKeeper集群必须选择出一个leader进程，同时leader会维护一个follower可用列表。
- 同步：leader要负责将本身的数据与follower完成同步，做到多副本存储。这样也是体现了CAP中高可用和分区容错，follower将队列中未处理完的请求消费完成后，写入本地事务日志中。
- 广播：leader可以接受客户端新的proposal请求，将新的proposal请求广播给所有的follower。

###  ZAB与Paxos算法的联系与区别

相同点：

1. 两者都存在一个类似于Leader进程的角色，由其负责协调多个Follower进程的运行
2. Leader进程都会等待超过半数的Follower作出正确的反馈后，才会将一个提案进行提交
3. ZAB协议中，每个Proposal中都包含一个epoch值来代表当前的Leader周期，Paxos中名字为Ballot

不同点：

​	ZAB用来构建高可用的分布式数据主备系统，Paxos是用来构建分布式一致性状态机系统

###  Znode四种类型

- 持久节点：除非手动删除，否则节点一直存在于ZooKeeper上
- 临时节点：临时节点的生命周期与客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除
- 持久顺序节点：同持久节点，增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。

##  ACL权限控制机制

ACL（Access Control List）访问控制列表包括三个方面：

###  权限模式（Scheme）

1. IP：从IP地址粒度进行权限控制
2. DIgest：类似于username：password的权限标识来进行权限配置，便于区分不同应用来进行权限控制
3. World：最开放的权限控制方式，是一种特殊的digest模式，只有一个权限标识“world：anyone”
4. Super：超级用户

###  授权对象

授权对象指的是权限赋予的用户或一个指定实体，例如IP地址。

###  权限

1. CREATE：数据节点创建权限，允许授权对象在该Znode下创建子节点
2. DELETE：子节点删除权限，允许授权对象删除该数据节点的子节点
3. READ：数据节点的读取权限，允许授权对象访问该数据节点并读取其数据内容或子节点列表等
4. WRITE：数据节点更新权限，允许授权对象对该数据节点进行更新操作
5. ADMIN：数据节点管理权限，允许授权对象对该数据节点进行ACL相关设置操作

##  服务器角色

###  Leader

1. 事务请求的唯一调度和处理者，保证集群事务处理的顺序性
2. 集群内部各服务的调度者

###  Follower

1. 处理客户端的非事务请求，转发事务请求给Leader服务器
2. 参与事务请求Proposal的投票
3. 参与Leader选举投票

###  Observer

1. 3.0版本后引入的一个服务器角色，在不影响集群事务处理能力的基础上提升集群的非事务处理能力
2. 处理客户端的非事务请求，转发事务请求给Leader服务器
3. 不参与任何形式的投票

##  Server工作状态

1. LOOKING：寻找Leader状态。当服务器处于该状态时，它会任务当前集群中没有Leader，因此需要进入Leader选举状态。
2. FOLLOWING：跟随者状态。表明当前服务器角色是Follower。
3. LEADING：领导者状态。表明当前服务器角色是Leader。
4. OBSERVING：观察者状态。表明当前服务器角色是Observer。

##  ZooKeeper是如何保证事务的顺序一致性的？

ZooKeeper采用了全局递增的事务ID来标识，所有的Proposal（提议）都在被提出的时候加上了zxid，zxid是一个64位的数字，高32位是epoch(时期；纪元；世；新时代)用来标识leader周期，如果有新的leader产生出来，epoch会自增，低32位用来递增计数。当新产生Proposal的时候，会依据数据库的两阶段过程，首先会向其他的server发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行。

##  ZooKeeper节点宕机如何处理？

ZooKeeper本身也是集群，推荐配置不少于3个服务器。ZooKeeper自身也要保证当一个节点宕机时，其它节点会继续提供服务。

如果是一个Follower宕机，还有两台服务器提供访问，因为ZooKeeper上的数据是有多个副本的，数据并不会丢失。

如果是一个Leader宕机，ZooKeeper会选举出新的Leader。

ZooKeeper集群的机制是只要超过半数的节点正常，集群就能正常提供服务，只有在ZooKeeper节点挂的太多，只剩一半或者不到一半的时候，集群才会失效。

##  ZooKeeper支持动态添加机器吗？

两种方式：

1. 全部重启：关闭所有ZooKeeper服务，修改配置后启动。
2. 逐个重启：在过半存活即可用的原则下，一台机器重启不影响整个集群对外提供服务。



##  ZooKeeper的典型应用场景

###  数据发布/订阅

####  介绍

数据发布/订阅系统，即配置中心，顾名思义就是发布者发布数据供订阅者进行数据订阅。

####  目的

动态获取数据（配置信息）

实现数据（配置信息）的集中式管理和数据的动态更新

####  基于ZooKeeper的实现方式

1. 数据存储：将数据（配置信息）存储到ZooKeeper上的一个数据节点
2. 数据获取：应用在启动初始化节点从ZooKeeper数据节点获取数据，并在该节点上注册一个数据变更Watcher
3. 数据变更：当变更数据时，更新ZooKeeper对应节点数据，ZooKeeper会将数据变更通知发到各个客户端，客户端接到通知后重新读取变更后的数据即可

### 负载均衡

### 命名服务

命名服务是通过指定的名字来获取资源或者服务的地址，利用ZooKeeper创建一个全局的路径，这个路径就可以作为一个名字，指向集群中的集群，提供的服务的地址或者一个远程的对象等等。

### 分布式协调/通知

对于系统调度来说：操作人员发送通知实际是通过控制台改变某个节点的状态，然后ZooKeeper将这些变化发送给注册了这个节点的watcher的所有客户端。

对于执行情况汇报：每个工作进程都在某个目录下创建一个临时节点。并携带工作的进度数据，这样汇总的进程可以监控目录子节点的变化获得工作进度的实时的全局情况。

### 集群管理

集群管理有两点：是否有机器退出和加入、是否选举master

对于第一点：所有机器约定在父目录下创建临时目录节点，然后监听父目录节点的子节点变化信息。一旦有机器挂掉，该机器与ZooKeeper的连接断开，其所创建的临时目录节点被删除，所有其它节点都收到通知：某个兄弟目录被删除。新机器加入也是类似，所有机器收到通知：新兄弟目录加入。

对于第二点：所有机器创建临时顺序编号目录节点，每次选取编号最小的机器作为master就好。

### Master选举

### 分布式锁

锁服务可以分为两类，一个是保持独占，另一个是控制时序。

对于第一类，我们将ZooKeeper上的一个Znode看作是一把锁，通过createZnode的方式来实现。所有客户端都去创建/distribute_lock节点，最终成功创建的那个客户端也即拥有了这把锁。用完删除掉自己创建的distribute_lock节点就释放了锁。

对于第二类，/distribute_lock已经预先存在，所有客户端在它下面创建临时顺序编号目录节点，和选master一样，编号最小的获得锁，用完删除。

### 分布式队列

1. 同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达。
   在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。
2. 队列按照FIFO方式进行入队和出队操作。
   和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按编号。在特定的目录下创建PERSISTENT_SEQUENTIAL节点，创建成功时watcher通知等待的队列，队列删除序列号最小的节点用以消费。此场景下ZooKeeper的Znode用于消息存储，Znode存储的数据就是消息队列中的消息内容，SEQUENTIAL序列号就是消息的编号，按序取出即可。

##  ZooKeeper watch机制

Watch机制官方声明：一个Watch事件是一个一次性的触发器，当被设置了Watch的数据发生了改变的时候，服务器则将这个改变发送给设置了Watch的客户端，以便通知它们。

###  特点

1. 一次性触发数据改变时，一个watch event会被发送到client，但是client只会收到一次这样的信息
2. watch event异步发送watcher的通知事件从server到client是异步的，会存在由于网络延迟或其他因素导致客户端在不通的时刻监听到事件，即我们使用ZooKeeper不能期望能够每次监控到节点的变化
3. 数据监视ZooKeeper有数据监视（getdata()）和子数据监视(getchildren())
4. 当一个客户端连接到一个新的服务器上时，watch将会被以任意会话事件触发。当与一个服务器失去连接时，是无法接收到watch的，而当client重新连接时，如果需要的话，所有先前注册过的watch，都会被重新注册
5. watch是轻量级的，其实就是本地JVM的CallBack，服务端只是存了是否有设置了watcher的布尔类型