#  Redis

##  为什么要用缓存？

主要从“高性能”和“高并发”来看待这两个问题

###  高性能

假如用户第一次访问数据库中的某些数据，这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存放在缓存中，下一次再访问数据的时候就可以直接从缓存中拿去了，操作缓存就是直接操作内存，所以速度相当快。

###  高并发

直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据复制到缓存中，这样用户的一部分请求会直接到缓存这里而不用经过数据库。

##  Redis和Memcached的区别

1. Redis支持更丰富的数据类型（支持更复杂的应用场景）：Redis不仅仅支持简单的k/v类型的数据，同时还提供list、set、zset、hash等类型的存储，Memcached仅支持String。
2. redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用，而Memcached把数据全部放在内存中。
3. Memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；Redis目前是原生支持cluster模式的。
4. Memcached是多线程，非阻塞IO复用的网络模型；Redis是使用单线程的多路IO复用模型。

##  Redis常见数据结构以及使用场景分析

###  String

常用命令：set、get、decr、incr、mget等。

String是简单的key-value类型，value不仅仅是String，还可以是数据。常规key-value缓存应用；常规技术：微博数、粉丝数等

###  Hash

常用命令：hset、hget、hgetall等。

Hash是一个String类型的field和value的映射表，Hash特别适合用于存储对象，后续操作的时候，可以直接仅仅修改这个对象中的某个字段的值。

>key=JavaUserVictor
>
>value={
>
>"id" : 1 ,
>
>"name" : "Victor",
>
>"age" : 20 
>
>}

###  List

常用命令：lpush、rpush、lpop、rpop、lrange等。

List为一个双向链表，是Redis最重要的数据结构之一，比如微博的关注列表、粉丝列表、消息列表等功能都可以用List来实现。

###  Set

常用命令：sadd、spop、smembers、sunion等。

Set提供了判断某个成员是否在一个set集合内的重要接口，这个也是List所不能提供的。可以基于Set轻易实现交集、并集、差集的操作。

Sorted Set

常用命令：zadd、zrange、zrem、zcard等。

和Set相比，Sorted Set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。

##  Redis的过期时间

Redis中可以对数据设置过期时间，应用场景：token过期、短信验证码等。



###  定期删除

Redis默认每隔100ms**随机**抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。如果遍历所有的设置过期时间的key的话，会给CPU带来很大的负载。

###  惰性删除

定期删除可能会导致很多过期key到了时间并没有被删除掉。惰性删除即当获取数据时检查key是否过期，如果过期就删除。

如果定期删除漏掉了很多key，然后也没有及时去查，就会导致大量key堆积在内存里，导致Redis内存块耗尽了，所以就有了Redis内存淘汰机制。

##  Redis内存淘汰机制

1. volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。
2. volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰。
3. volatile-random：从已设置过期时间的数据集中任意选择数据淘汰。
4. allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（最常用）
5. allkey-random：从数据集中任意选择数据淘汰。

##  Redis持久化机制

###  快照持久化（RDB）

Redis通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis创建快照后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本，还可以将快照留在原地以便重启服务器的时候使用。

###  AOF持久化

每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB的位置相同，都是通过dir参数设置的。

>appendfsync  always       每次有修改都会写入AOF文件
>
>appendfsync. everysec    每秒钟同步一次
>
>appendfsync  no              让操作系统决定何时进行同步

##  Redis事务

Redis通过MULTI、EXEC、WATCH等命令来实现事务功能。事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后去处理其他客户端的命令请求。

在Redis中，事务总是具有原子性、一致性和隔离性，并且当Redis运行在某种特定的持久化模式下，事务也具有持久性。