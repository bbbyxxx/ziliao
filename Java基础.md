#  Java基础

##  Java基础部分

###  面向对象和面向过程的区别

####  面向过程

1. 优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素时，采用面向过程开发
2. 缺点：没有面向对象易维护、易复用、易扩展

####  面向对象

1. 优点：易维护、易复用，可以设计出低耦合的系统，使系统更加灵活，更加易于维护
2. 缺点：性能比面向过程低

###  Java有哪些特性？

封装、继承、多态，平台无关性、可靠性、安全性、支持多线程、网络编程等。

- 继承：一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。新类可以从现有的类中派生，这个过程为类继承，新类继承了原始类的特性，新类则为原始类的派生类，原始类则为基类。
  - 子类拥有父类对象的所有的属性和方法（包括私有属性和私有方法），无权访问，仅拥有
  - 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展
  - 子类可以用自己的方式实现父类的方法（重写）
- 封装：把数据和过程包围起来，对数据的访问只能通过已定义的界面，面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其它对象。
- 多态：指允许不同类的对象对同一消息作出响应，即同一消息可以根据发送对象的不同而采用多种不同的行为方式。

###  什么是JVM？什么是字节码？

1. JVM：是运行Java字节码的虚拟机，JVM有针对不同系统的特定实现(Windows、Linux、macOS)

2. 字节码：在Java中，JVM可以理解的代码就叫做字节码(.class文件)，它不面对任何特定的处理器，只面向虚拟机。Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，并且，由于字节码并不针对一种特定的机器，因此，Java程序无须重续编译便可在多种不同操作系统的计算机上运行。

###  Java和C++的区别

- 都是面向对象的语言，支持封装、继承、多态
- Java不提供指针来直接访问内存，程序内存更加安全
- Java的类是单继承的，接口可以多继承，C++中支持多重继承
- Java有自动内存管理机制，不需要程序员手动释放无用内存

###  Java中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？

当一个对象被创建时，构造函数就会被调用，每一个类都有构造函数。在程序员没有给类提供构造函数的情况下，Java编译器会为这个类创建一个默认的构造函数。Java中构造函数重载和方法重载相似，可以为一个类创建多个构造函数。Java不支持像C++中那样的复制构造函数。

###  为什么重写equals()还要重写hashCode() ？

HashMap中，如果要比较key是否相等，要同时使用这两个方法，因为自定义的类的hashCode()方法继承于Object类，其hashCode()为默认的内存地址，这样即便有两个相同的对象，比较也是不相等的。HashMap中先检查key的hashCode()是否相等，如果相等再equals()，若相等则认为这两个key时相等的，这样比是因为我们可以重写hashCode()值使相同的key计算的hashCode()值相同，而Object中的equals()比的就是hashcode值，所以会存在判断出错，所以需要重写再进行一次判断。(即重写hashCode()必须重写equals())重写后如果两个对象的hashCode()值不同肯定这两个对象不相同，就不必再equals()。

- 相等的对象必须具有相同的哈希码
- 如果两个对象的hashCode相同，它们并不一定相等

```java
public boolean equals(Object obj) {
  return (this == obj); //如果两个对象的引用完全相同则返回true，如果是基本类型，就比较数值是否相等
}
```

### 一个十进制的数在内存中是怎么存的？

在计算机中是以补码的形式存储的，而二进制的小数无法精确的表达10进制小数，则在计算的过程中会产生误差 。

```java
float f = 4.0 - 3.6; //0.40000001则会出现误差
```

###  Java中的八大基本类型

byte（8位）、short（16位）、int（32）、long（64）、float（单精度，32位）、double（64位）、char（16位）、boolean（1位）。在Java中万物皆对象，对象抽象类，所以会有它们的包装类，分别对应（Byte）、（Short）、（Integer）、（Long）、（Float）、（Double）、（Character）、（Boolean）。故有自动装箱和拆箱，装箱即从基本数据类型转换为对应的包装类型，反之为拆箱。

```java
Integer integer = Integer.valueOf(1);
int i = integer.intValue();
/**
int和Integer的区别？
除了上述，还有一个就是Integer默认值为null，比如当一个考生缺考，此时就应该为null，而不是为0。
*/

/**
这里需要注意缓冲池的概念，当值在-128～127之间，会从缓冲池中返回，不在这个范围，初始化时则会在堆内存中新建对象并返回引用（地址不同，即hashCode()不同，可以重写hashCode()），至于为什么设计缓冲池这里不做概述。
相应的还有
ByteCache、ShortCache、LongCache、CharacterCache
*/
```

###  Java中到底是值传递还是引用传递？

在Java中没有引用传递，因为Java舍弃了指针，所有传参方式都是值传递，如果是基本型变量，则传递的是一个副本，改变副本不改变原值，而当传入一个对象型变量时，就是一个“引用传递”，此时传递的是对象地址的一个副本，对这个地址进行操作就会同时改变原对象，就类似于两个引用指向一个对象（浅拷贝）。

###  数组(Array)和列表(ArrayList)有什么区别？

- Array可以包含基本类型和对象类型，List只能包含对象类型
- Array大小是固定的，ArrayList大小是动态变化的（ArrayList初始化容量为10，每次扩容1.5倍 10->15->22...)
- ArrayList中提供了更多的方法和特性，比如add()、addfirst()等等
- ArrayList的底层实现就是一个动态的Array

###  String、StringBuffer、StringBuilder的区别？

Java平台提供。。。存储和操作字符串，即包含多个字符的字符数据，String是不可变得，其它两个是可变，并且StringBuffer为线程安全，当如果知道字符串数据要改变的时候并且线程安全就可使用StringBuffer。当改变String时，反编译可知道new了StringBuilder对象再进行append()。扩容机制：默认为16，当需要扩容时，先检查2*当前容量+2，如果不满足，则当前容量+准备存储的长度。

```java
int newCapacity = (value.length << 1)+2;
StringBuilder(int capacity)；
/*通过上面这个构造方法，如果初始容量为0，那么<<1会一直为0，那么扩容就失去了它的本质了*/
```

###  String为什么是不可变的？

不可变是指一个对象在创建完成后它的状态不能再改变，那么这个对象就是不可变的。我们知道String是被定义为final的，所以它是不可继承，而String的内部实现是一个char数组，这个数组是private final，即外部不可访问，一旦赋值后不可再更改。

1. 字符串常量是Java堆内存中一个特殊的存储区域，当创建一个String对象时，假如此字符串值已经存在于常量池中，则不会创建一个新的对象，而是引用已经存在的对象，假如字符串对象允许改变，那么将会导致各种逻辑错误，比如改变一个对象会影响到另一个独立对象，严格来说，常量池的思想是一种优化手段，如果String为可变，那么随着Java 程序的启动，堆内存中的对象越来愈多，性能将会急速下降。
2. Java中String对象的哈希码被频繁调用（HashMap），字符串不变性保证了hashCode的唯一性，因此可以放心的进行缓存，这样就不必每次都去计算进行新的hashCode

3. String被所有的类用来当作参数，例如URL，Path等等，如果不是不可变得，将会引起各种安全隐患

###  讲一讲Java中的final关键字怎么用的？

1. 当用final修饰一个类时，表明这个类不能被继承，也就是说如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。

2. 使用final时修饰方法会把方法锁定，以防任何继承类修改它的含义。

3. 修饰变量时，如果是基本类型的变量，则其数值一旦在初始化之后便不能更改，如果是引用类型的变量，那么在对其初始化之后便不能再让其指向另一个对象。

###  重载和重写的区别，相同参数不同返回值能重载吗？

重载（OverLoading）

1. 方法重载是让类以统一的方式处理不同类型数据的一种手段，多个同名方法同时存在，具有不同的参数个数/类型。
2. 方法的重载就是在类中可以创建多个方法，具有相同的名字，但具有不同的参数和定义。
3. 重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回类型作为重载函数的区分标准。

重写（Overriding）

  父类与子类之间的多态性，对父类的函数进行重新定义，如果再子类中定义某方法与其父类有相同的名称和参数，我们就说该方法被重写。重写也叫方法覆盖。

###  static关键字是什么意思？Java中是否可以覆盖一个private或者是static的方法？

static关键字表明一个成员变量或者是成员方法可以在不需要一个实例变量的情况下被访问。Java中private方法被继承后但是不能被访问，所以不能覆盖；方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的，static方法跟类的实例不相关，所以概念上不适用。

###  什么是泛型？

1. 定义：即“参数化类型”，也就是说操作的数据类型被指定为一个参数。

2. 好处：类型安全，提供编译期间的类型检测；前后兼容；泛化代码，代码可以更多的重复利用；消除强制类型转换
3. 类型擦除：通过类型参数合并，将泛型类型实例关联到同一份字节码上，编译器只为泛型类生成一份字节码，并将其实例关联到字节码上，类型擦除的关键在于从泛型类型中清除类型参数的相关信息，并且在必要的时候添加类型检查和类型转换的方法。

###  如何通过反射创建对象？

1. 通过类对象调用newInstance()方法，例如：String.class.newInstance()
2. 通过类对象的getConstructor()或getDeclaredConstructor()获得构造器 String.class.getConstructor(String.class).newInstance("Hello");

###  接口和抽象类的区别

- 抽象类可以有构造方法，接口中不能有构造方法
- 抽象类中可以有普通成员变量，接口中不能有普通成员变量，默认为public static final
- 抽象类中可以包含非抽象的普通方法，接口中的所有方法必须是抽象的
- 抽象类中的抽象方法的访问类型可以是public、protected和default，接口中的方法默认为public abstract
- 抽象类中可以包含静态方法，接口中不能
- 一个类可以实现多个接口，但只能继承一个抽象类

###  在Java中定义一个空构造的作用

Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会默认调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为在父类找不到没有参数的构造方法可供执行，解决方法就是在父类里加上一个不做事且没有参数的构造方法。

###  finla、finally、finalize的区别

- final用于声明属性、方法和类，表示属性不可变，方法不可覆盖，类不可继承
- finally是异常处理语句结构的一部分，表示总是执行
- finalize是Object类中的一个方法，在垃圾收集器执行的时候会调用被回收的此方法，可以覆盖此方法提供垃圾收集时的其它资源回收（尽量不要覆盖）

###  Java语言如何进行异常处理？关键字分别代表什么意义？

Java通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java 中，每个异常都是一个对象，是Throwable类或其它子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常对象，调用这个对象的方法可以捕获到这个异常并进行处理。

用try执行一段程序，如果出现异常，系统会抛出一个异常，这时你可以通过它的类型来catch它，或finally由缺省处理器来处理。throws用来标明一个成员函数可能抛出的各种异常，throw用来明确地抛出一个异常。

###  ArrayList和LinkedList的区别，如果一直在ArrayList的尾部添加元素，用哪个效率高？

ArrayList是采用数组实现的，查找效率比LinkedList高，LinkedList采用双向循环链表实现，插入和删除的效率比ArrayList高。

###  红黑树

- 每个节点要么是红色，要么是黑色
- 根结点永远是黑色
- 所有的叶子结点都是黑色
- 每个红色节点的两个子节点都是黑色
- 从任一节点到其子树中的叶子节点的路径都包含相同数量的黑色节点

###  ConcurrentHashMap1.7和1.8的区别？

ConcurrentHashMap是线程安全的，在1.7中采用Segment+HashEntry的方式进行实现，lock加在Segment上。1.7size计算是先采用不加锁的方式，连续计算元素的个数，最多计算3次：1、如果前后两次计算结果相同，则说明计算出来的元素个数是准确的；2、如果前后两次计算结果都不同，则给每个Segment进行加锁，再计算一次元素的个数；

1.8中放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现，1.8中使用一个volatile类型的变量baseCount记录元素的个数，当插入新数据或删除数据时，会通过addCount方法更新baseCount，通过累加baseCount和CounterCell数组中的数量，即可得到元素的总个数。

###  Collection和Collections的区别

Collection是集合类的上层接口，继承与它的接口主要有Set和List。它拥有基础的方法（add、addAll、remove、removeAll、iterator、

Collections是针对集合类的一个帮助类，它提供如下三类方法：

- 让集合不可变，当增删改的时候会报异常；
- 给集合加上锁，即方法上锁，安全但是效率低；
- 各种通用方法，二分查找、排序、逆序、打乱等等。

###  Java中的异常

Throwable是所有异常的父类，它有两个直接的子对象，分别是Error和Exception。其中Error是指我们无法处理的错误，比如说虚拟机异常、虚拟机内存溢出等无法控制的错误。Exception分为编译时异常和运行时异常，编译时常见的比如说ClassNotFoundException、IOException、SQLException等，运行时异常常见的就是空指针异常、数组越界、除0等在运行时才可以发现的异常。

我们必须对编译时异常进行处理，否则程序无法运行。但对运行时异常可以不处理，那么出现运行时异常后要么是线程终止，要么是主程序终止，如果不想终止，则必须捕捉所有的运行时异常

###  ArrayList

ArrayList是一个动态数组，因为它可以动态的扩充自己的容量，这个容量我们是看不见的，但是可以通过反射来进行访问。ArrayList的初始容量是10，扩容因子是1.5，也就是10->15->22->33，当第十一个元素插入时会进行扩容，底层是一个elementData数组，类型为Object。

如果初始容量定义为0，则返回一个空的elementData，当第一次add元素时会进行扩容，它的扩容就是一次拷贝，即Arrays.copyOf() /*即对数组进行拷贝*/，会消耗资源，所以尽量在初始化的时候就预计好容量以防资源浪费。ArrayList的删除和增加都是先检查插入或者删除的位置是否越界，越界了就抛出异常，插入会检查是否需要扩容，然后进行相关操作。

###  LinkedList

LinkedList是一个双向循环链表，有三个主要的属性，size、first和last，size即为链表当前有多少个节点，first为它的头节点（不放数据），last为尾节点。

add(index，element）先检查index是否越界，再检查index是否等于size，如果等于，就调用add(e) ，然后new一个节点，将新节点索引到index位置处的节点，把index节点添加到new节点的后面。

get首先判断是否越界，因为它有头节点和尾节点，所以会判断是从头节点开始遍历还是从尾节点开始遍历，判断方法是用index和size/2比，如果小于的话从first遍历，否则从last开始遍历。

##  Java高级部分

###  多线程中的i++线程安全吗？为什么？

不安全。i++不是原子性操作，i++分为取值、加1、再赋值，执行期中任何一步都是有可能被其他线程抢占的。

###  Java中有几种线程池

1. newFixedThreadPool：创建一个指定工作线程数量的线程池，每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将刚提交的任务存入到池队列中。
2. newCachedThreadPool：创建一个可根据实际情况调整线程数量的线程池。线程池的线程数量不稳定，但若有空闲线程可以复用，则会优先使用可服用的线程。若所有线程都在工作，又有新的任务提交，则会创建新的线程处理任务，所有线程在当前任务执行完毕后，将返回线程池进行复用。
3. newSingleThreadPool：创建只有一个线程的线程池。
4. newScheduleThreadPool：创建一个定长的线程池，而且支持定时的以及周期性的任务执行。

###  线程池有什么好处

- 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
- 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能执行。
- 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以统一分配、调优和监控。