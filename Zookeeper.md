#  ZooKeeper

ZooKeeper是一个开源的分布式协调服务。它是一个为分布式应用提供一致性服务的软件，分布式应用程序可以基于ZooKeeper实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列等功能。

##  CAP理论

###  Consistency：一致性

一致性是指数据在多个副本之间是否能够保持一致的特性，当系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处于一致的状态。

如果能够做到针对一个数据项的更新操作执行完成后，所有的用户都可以读取到其最新的值，那么这样的系统就被认为具有强一致性。

###  Availablility：可用性

可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。

”有限的时间内“是指，对于用户的一个操作请求，系统必须能够在指定的时间内返回对应的处理结果，如果超过了这个时间范围，那么系统就被认为是不可用的。

”返回结果“要求系统在完成对用户请求的处理后，返回一个正常的响应结果。正常的响应结果通常能过明确地反映出对请求的处理结果，即成功或失败，而不是一个让用户感到困惑的返回结果。

###  Partition tolerance：分区容错性

分区容错性约束了一个分布式系统需要具有如下特性：分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。

网络分区是指在分布式系统中，不同的节点分布在不同的子网络中，由于一些特殊的原因导致这些子网络之间出现网络不连通的状况，但各个子网络的内部网络是正常的，从而导致整个系统的网络环境被切分成了若干个孤立的区域。

###  放弃CAP定理

####  放弃C

指的是放弃强一致性，保留数据的最终一致性，这样的系统无法保证数据保持实时的一致性，但是能够承诺的是，数据最终会达到一个一致的状态。具体多久能够达到数据一致取决于系统的设计，主要包括数据副本在不同节点之间的复制时间长短。

####  放弃A

一旦系统遇到网络分区或其它故障时，那么收到影响的服务需要等待一定的时间，因此在等待期间系统无法对外提供正常的服务，即不可用。

####  放弃P

可以将所有数据都放在一个分布式节点上，这样不会出现由于网络分区带来的负面影响，但同时需要注意的是，放弃P就意味着放弃了系统的可扩展性。

##  BASE理论

BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来，核心思想是即使无法做到强一致性，但每个应用都可以根据自身的业务特点，采用适当的方式来达到最终一致性。

###  Basically Available(基本可用)

基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。比如说搜索引擎正常需要在0.5秒内返回结果，但由于出现故障，响应时间达到了1～2秒。

###  Soft state(软状态)

指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的时候出现延时。

###  Eventually consistent(最终一致性)

强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态，而需要实时保证系统数据的强一致性。

##  ZooKeeper保证了如下分布式一致性特性

1. 顺序一致性：从同一个客户端发起的事务请求，最终将会严格地按照其发起顺序被应用到ZooKeeper中去。
2. 原子性：所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的。
3. 单一视图：无论客户端连接的是哪个ZooKeeper服务器，其看到的服务端数据模型都是一致的。
4. 可靠性：一旦服务端成功地应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会被一直保留下来。
5. 实时性：ZooKeeper保证在一定的时间段内，客户端最终一定能够从服务端上读取到最新的数据状态。

##  ZooKeeper提供了什么？

- 文件系统
  - ZooKeeper提供一共多层级的节点命名空间(znode)，与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。
  - ZooKeeper为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这种特性使得ZooKeeper不能用于存放大量的数据，每个节点的存放数据上限为1M。
- 通知机制
  - ZooKeeper允许客户端向服务端的某个Znode注册一个Watcher监听，当服务端的一些指定事件触发了这个Watcher，服务端会向指定客户端发送一个事件通知来实现分布式的通知功能，然后客户端根据Watcher通知状态和事件类型做出业务上的改变。
  - 工作机制：
    1. 客户端注册watcher
    2. 服务端处理watcher
    3. 客户端回调watcher

###  ZAB协议

ZooKeeper的核心是原子广播机制，这个机制保证了各个server之间的同步，实现这个机制的协议叫做ZAB协议。ZAB协议有两种模式，恢复模式和广播模式。

####  恢复模式

当服务启动或者在leader崩溃后，ZAB就进入了恢复模式，当leader被选举出来，且大多数server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和server具有相同的系统状态。

####  广播模式

一旦leader已经和多数的follower进行了状态同步后，它就可以开始广播消息了，即进入广播状态。这时候当一个server加入ZooKeeper服务中，它会在恢复模式下启动，发现leader，并和leader进行状态同步。同步结束后，也加入消息广播，ZooKeeper服务一直维持在Broadcast状态，直到leader崩溃了或者leader失去了大部分的followers支持。

###  ZAP与Paxos算法的联系与区别

相同点：

1. 两者都存在一个类似于Leader进程的角色，由其负责协调多个Follower进程的运行
2. Leader进程都会等待超过半数的Follower作出正确的反馈后，才会将一个提案进行提交
3. ZAB协议中，每个Proposal中都包含一个epoch值来代表当前的Leader周期，Paxos中名字为Ballot

不同点：

​	ZAB用来构建高可用的分布式数据主备系统，Paxos是用来构建分布式一致性状态机系统

###  Znode四种类型

- 持久节点：除非手动删除，否则节点一直存在于ZooKeeper上
- 临时节点：临时节点的生命周期与客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除
- 持久顺序节点：同持久节点，增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。

##  ACL权限控制机制

ACL（Access Control List）访问控制列表包括三个方面：

###  权限模式（Scheme）

1. IP：从IP地址粒度进行权限控制
2. DIgest：类似于username：password的权限标识来进行权限配置，便于区分不同应用来进行权限控制
3. World：最开放的权限控制方式，是一种特殊的digest模式，只有一个权限标识“world：anyone”
4. Super：超级用户

###  授权对象

授权对象指的是权限赋予的用户或一个指定实体，例如IP地址。

###  权限

1. CREATE：数据节点创建权限，允许授权对象在该Znode下创建子节点
2. DELETE：子节点删除权限，允许授权对象删除该数据节点的子节点
3. READ：数据节点的读取权限，允许授权对象访问该数据节点并读取其数据内容或子节点列表等
4. WRITE：数据节点更新权限，允许授权对象对该数据节点进行更新操作
5. ADMIN：数据节点管理权限，允许授权对象对该数据节点进行ACL相关设置操作

##  服务器角色

###  Leader

1. 事务请求的唯一调度和处理者，保证集群事务处理的顺序性
2. 集群内部各服务的调度者

###  Follower

1. 处理客户端的非事务请求，转发事务请求给Leader服务器
2. 参与事务请求Proposal的投票
3. 参与Leader选举投票

###  Observer

1. 3.0版本后引入的一个服务器角色，在不影响集群事务处理能力的基础上提升集群的非事务处理能力
2. 处理客户端的非事务请求，转发事务请求给Leader服务器
3. 不参与任何形式的投票

##  Server工作状态

1. LOOKING：寻找Leader状态。当服务器处于该状态时，它会任务当前集群中没有Leader，因此需要进入Leader选举状态。
2. FOLLOWING：跟随者状态。表明当前服务器角色是Follower。
3. LEADING：领导者状态。表明当前服务器角色是Leader。
4. OBSERVING：观察者状态。表明当前服务器角色是Observer。

##  ZooKeeper是如何保证事务的顺序一致性的？

ZooKeeper采用了全局递增的事务ID来标识，所有的Proposal（提议）都在被提出的时候加上了zxid，zxid是一个64位的数字，高32位是epoch(时期；纪元；世；新时代)用来标识leader周期，如果有新的leader产生出来，epoch会自增，低32位用来递增计数。当新产生Proposal的时候，会依据数据库的两阶段过程，首先会向其他的server发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行。

##  ZooKeeper节点宕机如何处理？

ZooKeeper本身也是集群，推荐配置不少于3个服务器。ZooKeeper自身也要保证当一个节点宕机时，其它节点会继续提供服务。

如果是一个Follower宕机，还有两台服务器提供访问，因为ZooKeeper上的数据是有多个副本的，数据并不会丢失。

如果是一个Leader宕机，ZooKeeper会选举出新的Leader。

ZooKeeper集群的机制是只要超过半数的节点正常，集群就能正常提供服务，只有在ZooKeeper节点挂的太多，只剩一半或者不到一半的时候，集群才会失效。

##  ZooKeeper支持动态添加机器吗？

两种方式：

1. 全部重启：关闭所有ZooKeeper服务，修改配置后启动。
2. 逐个重启：在过半存活即可用的原则下，一台机器重启不影响整个集群对外提供服务。



##  ZooKeeper的典型应用场景

###  数据发布/订阅

####  介绍

数据发布/订阅系统，即配置中心，顾名思义就是发布者发布数据供订阅者进行数据订阅。

####  目的

动态获取数据（配置信息）

实现数据（配置信息）的集中式管理和数据的动态更新

####  基于ZooKeeper的实现方式

1. 数据存储：将数据（配置信息）存储到ZooKeeper上的一个数据节点
2. 数据获取：应用在启动初始化节点从ZooKeeper数据节点获取数据，并在该节点上注册一个数据变更Watcher
3. 数据变更：当变更数据时，更新ZooKeeper对应节点数据，ZooKeeper会将数据变更通知发到各个客户端，客户端接到通知后重新读取变更后的数据即可

### 负载均衡

### 命名服务

命名服务是通过指定的名字来获取资源或者服务的地址，利用ZooKeeper创建一个全局的路径，这个路径就可以作为一个名字，指向集群中的集群，提供的服务的地址或者一个远程的对象等等。

### 分布式协调/通知

对于系统调度来说：操作人员发送通知实际是通过控制台改变某个节点的状态，然后ZooKeeper将这些变化发送给注册了这个节点的watcher的所有客户端。

对于执行情况汇报：每个工作进程都在某个目录下创建一个临时节点。并携带工作的进度数据，这样汇总的进程可以监控目录子节点的变化获得工作进度的实时的全局情况。

### 集群管理

集群管理有两点：是否有机器退出和加入、是否选举master

对于第一点：所有机器约定在父目录下创建临时目录节点，然后监听父目录节点的子节点变化信息。一旦有机器挂掉，该机器与ZooKeeper的连接断开，其所创建的临时目录节点被删除，所有其它节点都收到通知：某个兄弟目录被删除。新机器加入也是类似，所有机器收到通知：新兄弟目录加入。

对于第二点：所有机器创建临时顺序编号目录节点，每次选取编号最小的机器作为master就好。

### Master选举

### 分布式锁

锁服务可以分为两类，一个是保持独占，另一个是控制时序。

对于第一类，我们将ZooKeeper上的一个Znode看作是一把锁，通过createZnode的方式来实现。所有客户端都去创建/distribute_lock节点，最终成功创建的那个客户端也即拥有了这把锁。用完删除掉自己创建的distribute_lock节点就释放了锁。

对于第二类，/distribute_lock已经预先存在，所有客户端在它下面创建临时顺序编号目录节点，和选master一样，编号最小的获得锁，用完删除。

### 分布式队列

1. 同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达。
   在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。
2. 队列按照FIFO方式进行入队和出队操作。
   和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按编号。在特定的目录下创建PERSISTENT_SEQUENTIAL节点，创建成功时watcher通知等待的队列，队列删除序列号最小的节点用以消费。此场景下ZooKeeper的Znode用于消息存储，Znode存储的数据就是消息队列中的消息内容，SEQUENTIAL序列号就是消息的编号，按序取出即可。