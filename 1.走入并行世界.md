# 高并发程序设计

# 走入并行世界

1. Java虚拟机除了要执行main函数主线程，还需要做JIT编译，需要做垃圾回收，这三个在jvm里都是一个单独的线程

2. 多核CPU：即将多个独立的计算单元整合到单独的CPU中

3. 同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的操作；异步方法通常会在另一个线程中执行，不会阻碍调用者的工作

4. 并发和并行都表示两个或者多个任务一起执行，但是侧重点不同，并发偏重于多个任务交替执行，而多个任务有可能还是串型的，并行才是真正意义上的“同时执行”。实际上，在真实环境中，并行只可能出现在拥有多个CPU的系统中

5. 临界区：表示一种公共资源（共享数据），可以被多个线程使用，但每一次只能有一个线程使用它，一旦临界区资源被占用，其他线程要想使用这个资源就必须等待

6. 饥饿：指某一个线程或多个线程因为种种原因无法获得所需要的资源，导致一直无法执行

7. 活锁：线程主动将资源释放给其他资源使用，会导致资源不断地在两个线程间跳动，没有一个线程拿到资源正常执行

8. 并发级别

   1. 阻塞：一个线程是阻塞的，那么在其  他线程释放资源之前，当前线程无法继续执行
   2. 无饥饿：线程之间是有优先级的，线程调度的时候总是会倾向于先满足高优先级的线程（可以参考一下公平锁的原理）
   3.  无障碍：是最弱的非阻塞的调度。两个线程如果无障碍地执行，那么不会因为临界区的问题导致一方被挂起

   > >大家一起修改共享数据，把数据该坏了怎么办？对于无障碍的线程来说，一旦检测到这种情况，它就会立即对自己所做的修改进行回滚，确保数据安全。

   4. 无锁：所有线程都能尝试对临界区进行访问，但不同的是，无锁的并发保证必然有一个线程能够在有限步内完成操作离开临界区

   > >在无锁的调用中，一个典型的特点就是可能会包含一个无穷循环。在这个循环中，线程会不断尝试修改共享变量。如果没有冲突，修改成功，那么程序退出，否则继续尝试修改。但无论如何，无锁的并行总能保证有一个线程is victor，不至于all failed，竞争失败的线程必须不断重试，直到自己success，否则会出现类似饥饿的情况

   ```java
   /*无锁示意代码，如果修改不成功，那么循环用不停止*/
   while(!atomicVar.compareAndSet(localVar,localVar+1)){
     localVar = atomicVar.get();
   }
   ```

   5. 无等待：无等待在无锁的基础上进一步扩展，它要求所有的线程必须在有限步内完成，这样就不会引起饥饿问题，如果超过这个步数，还可以进一步分解为有界无等待和线程无等待等几种，之间的区别只是对循环次数的限制不同

   > >无等待的经典结构就是RCU，基本思想是对数据的读不加控制。因此，所有的读线程都是无等待的，它们既不会被锁定等待也不会引起任何冲突。但在写数据的时候，先取得原始数据的副本，接着只修改副本数据，修改完成后，在合适的时机写回数据。

9. 有关并行的两个定律：为了获得更好的性能，需要多个执行实体

   >Amdahl定律：当串型化比例一定时，加速比是有上限的，不管堆叠多少个CPU计算，都不能突破这个上线
   >
   >Gustafson定律：如果可被并行化的代码所占比例足够大，那么加速比就能随着CPU的数量线性增长

10. JMM的关键技术点都是围绕着多线程的原子性、可见性和有序性来建立的

    1. 原子性：指一个操作是不可中断的，即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰

       > >对于一个静态变量i，当有两个线程同时赋值时，i的值只能为这两个线程赋的值其中一个，也就是说这两个线程之间是不存在干扰的，在这需要注意的是如果是32位系统，long型数据的读写不是原子性的（long型数据有64位），会存在线程间相互干扰，由于并行的关系，数字被写乱了，或者读串位了

    2.  可见性：指当一个线程修改了某一个共享变量的值时，其他线程是否立即知道这个修改。（推荐了解MESI缓存一致性协议）

       > >Java程序在jdk1.2之前会直接从主内存拿取数据，在之后有了工作内存（即缓存），每次读取值会从工作内存中读取，当写入值的时候就会存在写入工作内存中没有更新主内存的值

    3. 有序性：程序在执行时，可能会进行指令重排，重排后的指令与原指令的顺序未必一致。指令重排对于提高CPU处理性能是十分必要的，但是确实带来了乱序的问题

       > >符合Happens-Before规则的指令不能重排
       > >
       > >a. 程序顺序原则：一个线程内保证语义的串行性
       > >
       > >b. volatile规则：volatile变量的写先于读发生，保证了可见性
       > >
       > >c. 锁规则：解锁(unlock)必然发生在随后的加锁(lock)前 
       > >
       > >d. 传递性：A先于B，B先于C，则A先于C
       > >
       > >e. 线程的start方法先于它的每一个动作
       > >
       > >f. 线程的所有操作先于线程的终结（Thread.join())
       > >
       > >g. 线程的中断(interrupt)先于被中断程序的代码
       > >
       > >h. 对象构造函数的执行、结束先于finalize()方法