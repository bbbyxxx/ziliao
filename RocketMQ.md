#  RocketMQ

##  为什么要用MQ？

- 解耦：系统耦合性低，没有强依赖关系

- 异步：不需要同步执行的远程调用可以有效提高响应时间
- 削峰：请求达到峰值后，后端service还可以保持固定消费速率消费，不会被压垮

##  RocketMQ由哪些角色组成，每个角色作用和特点是什么？

###  NameServer：

NameServer是一个功能齐全的服务器，其角色类似Dubbo中的Zookeeper，但NameServer与Zookeeper相比更轻量，每个NameServer节点互相之间是独立的，没有信息交互，所以压力不会很大，平时主要开销是在维持心跳和提供topic----broker的关系数据。

NameServer被设计成无状态的，可以横向扩展，节点之间相互无通信，通过部署多台机器来标记自己是一个伪集群。每个broker在启动的时候会到NameServer注册，Producer、Consumer会根据topic到NameServer获取到Broker的路由信息。

###  Producer

消息生产者，负责产生消息。

- Producer由用户进行分布式部署，消息由Producer通过多种负载均衡模式发送到Broker集群，发送低延时，支持快速失败
- RocketMQ提供了三种方式发送消息：同步、异步和单向
  - 同步发送：同步发送指消息发送方发出数据后会在收到接收方发回响应之后才发下一个数据包
  - 异步发送：异步发送指发送方发出数据后，不等接收方发回响应接着发送下个数据包，一般用于可能链路耗时较长而对响应时间敏感的业务
  - 单向发送：单向发送是指只负责发送消息而不等待服务器回应且没有回调函数触发，适用于某些耗时非常短对可靠性要求并不高的场景

###  Broker

消息中转角色，负责存储消息、转发消息。

- Broker是具体提供业务的服务器，单个Broker节点与所有的NameServer节点保持长连接及心跳，并会定时将Topic信息注册到NameServer
- Broker负责消息存储，以Topic为维度支持轻量级的队列，单机可以支撑上万队列规模，支持消息推拉模型
- 具有上亿级消息消息堆积能力，可严格保证消息的有序性

###  Consumer

消息消费者，负责消费消息。

- 支持推拉两种消费模式，支持集群消费和广播消息，提供实时的消息订阅机制
- Pull：主动消费型，拉取型消费者主动从消息服务器拉取消息，只要批量拉取到消息，用户应用就会启动消费过程
- Push：被动消费型，推送型消费者封装了消息的拉取、消费进度和其他的内部维护工作，将消息到达时执行的回调接口留给用户应用程序来实现

###  Message

Message就是要传输的消息，一条消息必须有一个主题（Topic）。

####  Topic

消息的归类，消息的第一级类型，Topic与生产者和消费者的关系非常松散，一个Topic可以有多个生产者向其发送消息，一个生产者也可以同时向不同的Topic发送消息，同时一个Topic也可以被多个消费者订阅消费。

####  Tag

子主题，消息的第二级类型，用于为用户提供额外的灵活性。使用标签，同一业务模块不同目的的消息就可以用相同的Topic和不同的Tag来标识。

####  Group

一个组可以订阅多个Topic，分为ProducerGroup、ConsumerGroup，代表某一类的生产者和消费者，一般来说同一个服务可以作为Group，同一个Group发送和消费的消息都是一样的。

####  Queue

在RocketMQ中分为读和写两种队列，一般来说读写队列数量一致。主题被划分为一个或多个子主题，即消息队列。一个Topic下可以设置多个消息队列，发送消息时执行该消息的Topic，RocketMQ会轮询该Topic下的所有队列将消息发出去。



