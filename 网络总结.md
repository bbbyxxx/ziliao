#  网络部分面试题

##  POST和GET的区别

###  GET

请求的数据会附加在URL之后，以？分割URL和传输数据，多个参数用&连接。URL的编码格式采用的是ASCII编码，而不是unicode。即所有的非ASCII字符都要编码之后再传输

###  POST

请求会把数据放置在http请求的包体中。

###  区别

- 传输数据的大小：在http请求中，没有对url的长度和传输的数据大小进行限制。但是在实际的开发过程中，对于GET，特定的浏览器和服务器对url的长度有限制。因此，在使用GET请求时，传输数据会收到url长度的限制。对于POST，理论上是不会受限制的，但是实际上各个服务器会规定对POST提交数据大小进行限制。比如tomcat在7.0版本之前默认是2m，如果大于2m就接受不到值，解决办法是在server.xml中修改maxPostSize。
- 安全性：POST比GET更安全，在进行登录操作时，密码和用户名就会被暴露在url上，并且登录页面有可能被浏览器缓存，此时密码就更容易被他人拿到了。

##  http常见状态码

### 10X

代表请求已被接受，需要继续处理。是临时响应，只包含状态行和某些可选的响应头信息。

- 100：客户端应当继续发送请求。
- 101：服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。
- 102：扩展的状态码，代表处理将被继续执行。

###  20X

代表请求已被服务器接收、理解、接受。

- 200：请求成功，请求所希望的响应头或数据体将随此响应返回。表示正常状态。
- 201：请求已被实现，并且有新的资源依据请求的需要而建立。
- 202：接受请求，但尚未处理，可能会被拒绝或者不被执行。
- 203：成功处理了请求，返回的实体头部信息是来自本地或者第三方的拷贝。

###  30X

代表客户端需要采取进一步的操作才能完成请求，后续的请求地址在本次响应的Location域中指明。

- 300：针对请求，服务器可做多种操作。
- 301：永久移动，请求的页面已永久跳转到新的url。
- 302：临时移动，服务器目前从不同的网页响应请求，但请求仍继续使用原有位置来进行以后的请求。
- 303：查看其它位置，请求应当对不同的位置使用单独的GET请求来检索响应。

###  40X

代表客户端可能发生了错误，妨碍了服务器的处理。

- 400：错误请求，服务器不理解请求的语法。
- 401：未授权，请求要求用户的身份验证。
- 403：服务器拒绝请求。
- 404：服务器找不到请求的页面。

###  50X

服务端在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到当前的软硬件资源无法完成对请求的处理。

- 500：一般会在源代码出现错误时出现。
- 501：服务器不具备完成请求的功能。
- 502：服务器作为网关或者代理出现错误。
- 503：服务器目前无法使用。
- 504：网管或代理服务器，未及时获取请求。

##  Cookie和Session的区别

###  session

由于http协议是无状态的协议，所以当服务端需要记录用户的状态时，就需要用某种机制来识别具体的用户，这个机制就是session。这个机制就是session，典型的场景比如购物车，当点击收藏按钮时，由于http协议无状态，所以不知道是哪个用户操作的，所以服务端需要创建session来标识这个用户并且跟踪用户，这样才可以知道购物车里的东西。session是保存在服务端的，会有一个唯一的sessionID来识别。

###  cookie

sessionID是存在cookie中的，而cookie存放在客户端，当cookie把sessionID发送到服务器，服务器就会识别出指定的客户。即大多数的应用都是用cookie来实现session跟踪的，但如果浏览器禁用了cookie，一般会使用URL重写的技术来进行会话跟踪，（url+sid=xxx），服务端据此来识别用户。

- session存在服务器端（文件、数据库、内存里），cookie在客户端（浏览器）
- session的运行依赖sessionID，而sessionID是存在cookie中的
- 用户验证一般会用session
- cookie不是很安全，可以进行cookie欺骗

##  ICMP

互联网控制消息协议，承担网络层通信差错检测和报告机制的协议，ping命令就是基于ICMP协议来验证网络层连通性的工具。

##  TCP协议

TCP协议能够对自己提供的连接实施控制，是一种可靠的传输层协议，传输层协议最本质的任务就是把网络层协议提供的终端之间的通信服务，扩展到终端系统中运行的应用程序之间。也就是说在为应用进程建立通信之前，TCP需要首次建立传输数据所需的连接，一旦TCP连接建立成功，应用进程之间就可以通过这条TCP连接相互发送上层数据了。

###  TCP是通过什么方式来提供可靠传播的

- 对数据进行分割和充足：TCP能够将数据分割为适当大小进行传输。
- 确保数据按顺序传输：会为自己发出的数据标明序列号。
- 同时为多个应用程序提供传输服务：通过端口号把应用进程和数据的对应关系搞清楚。
- 确保接收方收到数据并按需重传：TCP要求接收方在接收到数据后，对发送方进行确认，如果发送方未收到确认标志，那么发送方将会再次发送数据。
- 控制传输速率：使用滑动窗口机制，使接收方能够调节发送方的发送速率。

###  TCP头部

- 源端口：源设备上应用进程所使用的TCP端口号
- 目的端口：指明目的设备上应用进程所使用的TCP端口号
- 序列号：表示发送数据的位置
  - 保证报文按序到达
  - 保证可靠性
  - 保证效率
  - 精确的报告哪些收到，哪些需要重传
- 确认号：确认已收到的数据
- 头部长度：标识TCP头部的总长度
- 窗口大小：接收多少字节的数据

###  TCP连接

TCP建立的是双向连接，当客户端与服务器之间数据传输完毕后，TCP会拆除已建立的连接。

####  三次握手过程

- 客户端向服务器发送TCP连接建立请求
- 服务器向客户端返回标识了SYN和ACK的数据段
- 客户端向服务器发送ACK数据段进行响应

####  意义

- 确保接收方收到了发送方的数据
- 发送方按照接收方的处理能力发送数据，避免不必要的丢包重传

####  四次挥手过程

- 客户端向服务器发送请求中断连接（FIN）
- 服务器向客户端发送ACK表示请求收到，客户端进入请求等待状态
- 服务器向客户端发送中断请求
- 客户端收到后发送ACK表示收到，进入TIME_WAIT状态（如果服务器没有收到ACK则重传，等待时间到后没有收到重传信息，则说明服务器已经关闭）

###  应用场景

当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议

##  各层功能简述

传输层：建立端口到端口的通信。

网络层：建立主机到主机的通信

数据链路层：两台主机之间的数据传输，总是在一段一段的链路上传输的，这就需要使用专门的链路层协议。在两个节点传送数据时，数据链路层将网络层交下来的IP数据包组装成帧，在两个节点的链路上传送帧，每一帧包括数据和必要的控制信息。

物理层：把两台计算机连起来，然后在计算机之间通过高低电频来传送0，1电信号，尽可能屏蔽掉具体传输介质和物理设备的差异。

##  http和https的区别

- https协议要申请证书到ca（证书颁发机构，是负责发放和管理数字证书的权威机构），需要一定经济成本。
- http是明文传输，https是加密的安全传输。
- 连接的端口不一样，http是80，https是443。
- http连接简单，没有状态，https是ssl加密的传输，身份认证的网络协议，相对http传输比较安全。

##  http1.1和1.0的区别

- 缓存处理，http1.0中主要使用header里的If-Modified-Since，Expires来作为缓存判断的标准，http1.1则引入了更多的缓存控制策略如Entity tag，If-Unmodified-Since，If-Match，If-None-Mathch等更多可供选择的缓存头来控制缓存策略。
- 带宽优化及网络连接的使用，在1.0中，存在带宽浪费的现象，比如客户端只需要某个对象的一部分，但是服务器却将整个对象送过来，并且不支持断点续传功能，1.1则在请求头引入了range头域，它允许只请求资源的某个部分，这样就方便了开发者自由的选择以便于充分利用带宽和连接。
- 错误通知的管理，在1.1中新增了24个错误状态响应码。
- Host头处理，在1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名。但随着虚拟主机技术的发展，在一台物理服务器上可以存在都个虚拟主机，并且共享一个IP地址。1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告400错误。
- 长连接，1.1支持长连接和请求的流水线处理，在一个tcp连接上可以传送多个http请求和响应，减少了建立和关闭连接的消耗和延迟，在http1.1中默认开启Connection:keep-alive，一定程度上弥补了http1.0每次请求都要创建连接的缺点。

###  ssl四次握手过程

- 客户端发出加密通信请求（ClientHello）
- 服务器收到客户端请求后作出响应（ServerHello）
- 客户端收到服务器回应以后，首先验证服务器证书，如果证书不是可信机构颁布、证书中的域名与实际中的域名不一致、证书已过期，就会向访问者显示警告，由其选择是否还要继续通信。
- 服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的“会话密钥”。然后发送如下信息：
  1. 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送
  2. 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项也是前面发送的所有内容的hash值，用来供客户端校验。

至此，整个握手阶段结束，接下来就会使用加密后的http协议来进行通信。

##  DNS寻址过程

- 首先会检查本地hosts文件是否有这个映射关系，如果有，就优先调用。
- 如果hosts里没有，则会在本地DNS解析器缓存，查看是否有网址映射关系。
- 如果没有，继续查TCP/IP参数中设置的首选DNS服务器（本地）。此服务器收到查询时，如果要查询的域名包含在本地配置中，则返回解析结果给客户机，完成域名解析；如果不在本地，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。
- 如果都失效，则根据本地DNS服务器设置进行查询，然后从.com进行解析，如果自己无法解析，就会下一级qq.com给本地DNS服务器，直至找到www.qq.com主机（未用转发模式）；如果是转发模式，就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，如果不能解析，就会转至上上级，以此循环。