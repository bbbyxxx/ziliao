#  RocketMQ

##  为什么要用MQ？

- 解耦：系统A和系统B通过同步调用的模式耦合在一起，一旦系统B出现故障，很有可能系统A也被影响，引入MQ后系统B出现故障后，A无法感知到，也就不会有影响

- 异步：调用A、B两个系统，执行业务逻辑需要20、200ms，一共需要220ms，引入MQ后可以就很快返回结果给用户
- 削峰：如果高并发访问系统A，那么瓶颈就在于DB操作，同样的机器配置下，DB可以抗6000/s请求，MQ至少可以抗几万/s请求，引入MQ后，A系统可以以自己合适的速度去访问MQ，即达到削峰的目的

##  RocketMQ由哪些角色组成，每个角色作用和特点是什么？

###  NameServer：

NameServer是一个功能齐全的服务器，其角色类似Dubbo中的Zookeeper，但NameServer与Zookeeper相比更轻量，每个NameServer节点互相之间是独立的，没有信息交互，所以压力不会很大，平时主要开销是在维持心跳和提供topic----broker的关系数据。

NameServer被设计成无状态的，可以横向扩展，节点之间相互无通信，通过部署多台机器来标记自己是一个伪集群。每个broker在启动的时候会到NameServer注册，Producer、Consumer会根据topic到NameServer获取到Broker的路由信息。

###  Producer

消息生产者，负责产生消息。

- Producer由用户进行分布式部署，消息由Producer通过多种负载均衡模式发送到Broker集群，发送低延时，支持快速失败
- RocketMQ提供了三种方式发送消息：同步、异步和单向
  - 同步发送：同步发送指消息发送方发出数据后会在收到接收方发回响应之后才发下一个数据包
  - 异步发送：异步发送指发送方发出数据后，不等接收方发回响应接着发送下个数据包，一般用于可能链路耗时较长而对响应时间敏感的业务
  - 单向发送：单向发送是指只负责发送消息而不等待服务器回应且没有回调函数触发，适用于某些耗时非常短对可靠性要求并不高的场景

###  Broker

消息中转角色，负责存储消息、转发消息。

- Broker是具体提供业务的服务器，单个Broker节点与所有的NameServer节点保持长连接及心跳，并会定时将Topic信息注册到NameServer
- Broker负责消息存储，以Topic为维度支持轻量级的队列，单机可以支撑上万队列规模，支持消息推拉模型
- 具有上亿级消息消息堆积能力，可严格保证消息的有序性

###  Consumer

消息消费者，负责消费消息。

- 支持推拉两种消费模式，支持集群消费和广播消息，提供实时的消息订阅机制
- Pull：主动消费型，拉取型消费者主动从消息服务器拉取消息，只要批量拉取到消息，用户应用就会启动消费过程
- Push：被动消费型，推送型消费者封装了消息的拉取、消费进度和其他的内部维护工作，将消息到达时执行的回调接口留给用户应用程序来实现

###  Message

Message就是要传输的消息，一条消息必须有一个主题（Topic）。

####  Topic

消息的归类，消息的第一级类型，Topic与生产者和消费者的关系非常松散，一个Topic可以有多个生产者向其发送消息，一个生产者也可以同时向不同的Topic发送消息，同时一个Topic也可以被多个消费者订阅消费。

####  Tag

子主题，消息的第二级类型，用于为用户提供额外的灵活性。使用标签，同一业务模块不同目的的消息就可以用相同的Topic和不同的Tag来标识。

####  Group

一个组可以订阅多个Topic，分为ProducerGroup、ConsumerGroup，代表某一类的生产者和消费者，一般来说同一个服务可以作为Group，同一个Group发送和消费的消息都是一样的。

####  Queue

在RocketMQ中分为读和写两种队列，一般来说读写队列数量一致。主题被划分为一个或多个子主题，即消息队列。一个Topic下可以设置多个消息队列，发送消息时执行该消息的Topic，RocketMQ会轮询该Topic下的所有队列将消息发出去。

##   消息消费模式

- 集群消费（Cluster）：该模式下一个消费者集群共同消费一个主题的多个队列，一个队列只会被一个消费者消费，如果某个消费者挂掉，分组内其他消费者会接替挂掉的消费者继续消费。
- 广播消息（BroadCast）：广播消费消息会发给消费者组中的每一个消费者进行消费。

##  消息去重

去重原则：使用业务端逻辑保持幂等性。

幂等性：用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用，数据库的结果都是唯一的、不可变的。

去重策略：保证每条消息都有唯一编号，且保证消息处理成功与去重表的日志同时出现。（建立一个消息表，拿到这个消息做数据库的insert操作，给消息做唯一主键或唯一约束，那么出现重复消费的情况就会导致主键冲突）

##  消息的可用性

RocketMQ对消息的刷盘提供了同步和异步的策略，选择同步刷盘，刷盘超时会返回FLUSH_DISK_TIMEOUT，异步刷盘不会返回相关信息，选择同步可以保证消息不丢失。（同步高可用，异步高响应）

RocketMQ为每个Broker实例下所有的队列共用一个日志数据文件（CommitLog）来存储。