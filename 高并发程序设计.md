# 高并发程序设计

## 走入并行世界

### Java虚拟机中的线程

除了要执行main函数主线程，还需要做JIT编译，需要做垃圾回收，这三个在jvm里都是一个单独的线程

### 什么是多核CPU

即将多个独立的计算单元整合到单独的CPU中

### 同步和异步

同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的操作；异步方法通常会在另一个线程中执行，不会阻碍调用者的工作

### 并发和并行

并发和并行都表示两个或者多个任务一起执行，但是侧重点不同，并发偏重于多个任务交替执行，而多个任务有可能还是串型的，并行才是真正意义上的“同时执行”。实际上，在真实环境中，并行只可能出现在拥有多个CPU的系统中

### 临界区

表示一种公共资源（共享数据），可以被多个线程使用，但每一次只能有一个线程使用它，一旦临界区资源被占用，其他线程要想使用这个资源就必须等待

### 饥饿

指某一个线程或多个线程因为种种原因无法获得所需要的资源，导致一直无法执行

### 活锁

线程主动将资源释放给其他资源使用，会导致资源不断地在两个线程间跳动，没有一个线程拿到资源正常执行

### 并发级别

1. 阻塞：一个线程是阻塞的，那么在其  他线程释放资源之前，当前线程无法继续执行
2. 无饥饿：线程之间是有优先级的，线程调度的时候总是会倾向于先满足高优先级的线程（可以参考一下公平锁的原理）
3.  无障碍：是最弱的非阻塞的调度。两个线程如果无障碍地执行，那么不会因为临界区的问题导致一方被挂起

> 大家一起修改共享数据，把数据该坏了怎么办？对于无障碍的线程来说，一旦检测到这种情况，它就会立即对自己所做的修改进行回滚，确保数据安全。

4. 无锁：所有线程都能尝试对临界区进行访问，但不同的是，无锁的并发保证必然有一个线程能够在有限步内完成操作离开临界区

> 在无锁的调用中，一个典型的特点就是可能会包含一个无穷循环。在这个循环中，线程会不断尝试修改共享变量。如果没有冲突，修改成功，那么程序退出，否则继续尝试修改。但无论如何，无锁的并行总能保证有一个线程is victor，不至于all failed，竞争失败的线程必须不断重试，直到自己success，否则会出现类似饥饿的情况

```java
/*无锁示意代码，如果修改不成功，那么循环用不停止*/
while(!atomicVar.compareAndSet(localVar,localVar+1)){
  localVar = atomicVar.get();
}
```

5. 无等待：无等待在无锁的基础上进一步扩展，它要求所有的线程必须在有限步内完成，这样就不会引起饥饿问题，如果超过这个步数，还可以进一步分解为有界无等待和线程无等待等几种，之间的区别只是对循环次数的限制不同

> 无等待的经典结构就是RCU，基本思想是对数据的读不加控制。因此，所有的读线程都是无等待的，它们既不会被锁定等待也不会引起任何冲突。但在写数据的时候，先取得原始数据的副本，接着只修改副本数据，修改完成后，在合适的时机写回数据。

### 有关并行的两个定律

 a. 为了获得更好的性能 b. 需要多个执行实体

>Amdahl定律：当串型化比例一定时，加速比是有上限的，不管堆叠多少个CPU计算，都不能突破这个上线
>
>Gustafson定律：如果可被并行化的代码所占比例足够大，那么加速比就能随着CPU的数量线性增长

### JMM的关键技术点

都是围绕着多线程的原子性、可见性和有序性来建立的

#### 原子性

指一个操作是不可中断的，即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰

> 对于一个静态变量i，当有两个线程同时赋值时，i的值只能为这两个线程赋的值其中一个，也就是说这两个线程之间是不存在干扰的，在这需要注意的是如果是32位系统，long型数据的读写不是原子性的（long型数据有64位），会存在线程间相互干扰，由于并行的关系，数字被写乱了，或者读串位了

#### 可见性

指当一个线程修改了某一个共享变量的值时，其他线程是否立即知道这个修改。（推荐了解MESI缓存一致性协议）

> Java程序在jdk1.2之前会直接从主内存拿取数据，在之后有了工作内存（即缓存），每次读取值会从工作内存中读取，当写入值的时候就会存在写入工作内存中没有更新主内存的值

#### 有序性

程序在执行时，可能会进行指令重排，重排后的指令与原指令的顺序未必一致。指令重排对于提高CPU处理性能是十分必要的，但是确实带来了乱序的问题

> 符合Happens-Before规则的指令不能重排
> 
> a. 程序顺序原则：一个线程内保证语义的串行性
> 
> b. volatile规则：volatile变量的写先于读发生，保证了可见性
> 
> c. 锁规则：解锁(unlock)必然发生在随后的加锁(lock)前 
> 
> d. 传递性：A先于B，B先于C，则A先于C
> 
> e. 线程的start方法先于它的每一个动作
> 
> f. 线程的所有操作先于线程的终结（Thread.join())
> 
> g. 线程的中断(interrupt)先于被中断程序的代码
> 
> h. 对象构造函数的执行、结束先于finalize()方法

## Java并行程序基础

### 进程和线程

进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期，进程是程序的基本执行实体，程序是指令、数据及其组织形式的描述，进程是程序的实体，在目前，进程是线程的容器。线程就是轻量级进程，是 程序执行的最小单位，线程间的切换和调度的成本远远小于进程

```java
/**
线程的所有状态
注意：从NEW状态出发后，不能再回到NEW状态，TERMINATED同理
*/
public enum State {
  NWE,//刚刚创建的线程，还没开始执行
  RUNNABLE,//当调用start方法时，线程开始执行
  BLOCKED,//遇到了synchronized同步块
  WAITING,//无时间限制的等待
  TIMED_WAITING,//有时限的等待
  TERMINATED;//线程执行完成
} 
```

### 线程的基本操作

#### 新建线程

```java
Thread t1 = new Thread();
t1.start();
//调用start方法是开启一个线程，而调用run方法只是作为一个普通的方法调用	
```

#### 终止线程

在调用stop方法时，会直接终止线程，并释放这个线程所持有的锁，这些锁恰恰是用来维持对象一致性的。如果此时，写线程写入数据正写到一半，并强行终止，那么对象就会被写坏，同时，由于锁已经被释放，另外一个等待该锁的读线程就顺理成章的读到了这个不一致的对象，悲剧也就此发生。如果要停止一个线程，可以写一个方法来进行一个退出

#### 线程中断

不会使线程立即退出，而是给线程发送一个通知，告知目标线程需要退出。 

```java
public void interrupt();										 	//中断线程 
public boolean isInterrupted();						   	//判断是否被中断
public static boolean interrupted();					//判断是否被中断，并清除
/*如果希望t1在中断后退出，就必须为它增加相应的中断处理代码*/
Thread t1 = new Thread(){
  @Override
  public void run(){
    while(true){
      if(Thread,currentThread().isInterrupted()){
        System.out.println("Interrupted");
        break;
      }
      Thread.yield();
    }
  }
}
```

#### wait和notify

1. 这两个方法是在Object类，表示**任何对象**都可以调用这两个方法

2. 当在一个对象实例上调用wait方法后，当前线程就会在这个对象上等待，并进入阻塞状态，直到其他线程调用notify或者notifyAll方法为止，这时，该对象就成了多个线程之间的有效通信手段

3. wait工作过程：当一个线程调用了object.wait()方法，那么它就会进入object对象的等待队列，这个等待队列中，可能会有多个线程同时等待某一个对象，当object.notify()方法被调用时，会从这个等待队列中**随机**选择一个线程，并将其唤醒。注意：wait方法不能随便调用，必须包含在synchronized语句中，无论是wait还是notify都需要首先获得目标对象的一个监视器。

4. wait方法执行后，会释放监视器，目的是使其他等待在object对象上的线程不至于因为T1的休眠而全部无法执行。线程T2在notify方法调用前，也**必须**获得object对象的监视器，再尝试唤醒一个等待线程，假设唤醒T1，此时T1要做的第一件事就是重新获得obejct对象的监视器，也正是T1在wait方法执行前所持有的那个，**必须获得后才可以继续执行**

5. Object.wait()方法和Thread.sleep()方法都可以让线程等待若干时间，除wait方法可以被唤醒外，另外一个主要的区别就是wait方法会释放目标对象的锁，而**sleep方法不会释放任何资源**

6. suspend和resume

   > suspend在导致线程暂停的同时，并不会释放任何锁资源，其他任何线程想要访问被它占用的锁时，都会被牵连，导致无法正常继续运行，直到对应的线程上进行了resume操作，被挂起的线程才能继续，从而其它所有阻塞在相关锁上的线程也可以继续执行。但是，如果resume在suspend前执行，那么就会导致被挂起的线程很难再继续执行，并且锁不会被释放，导致整个系统工作不正常

#### join和yield

1. join，一个线程的输入可能非常依赖于另一个或者多个线程的输出，这个线程就必须要等待依赖线程执行完毕

   ```java
   /*表示无限等待，会一直阻塞当前线程，直到目标线程执行完毕*/
   public final void join() throws InterruptedExcepton
   /*如果超过给点时间目标线程还在执行，当前线程就会继续执行*/
   public final synchronized void join(long millis) throws InterruptedExcepton
     
   /*join方法的本质是让调用线程wait方法在当前线程对象实例上*/
   while(isAlive()){
     wait(0);
   }
   public class Solution {
       public volatile static int i = 0;
   		public static class AddThread extends Thread{
       @Override
       public void run() {
           Long start = System.currentTimeMillis();
           for (i=0;i<10000000;i++);
           Long end = System.currentTimeMillis();
           System.out.println(end - start);
       }
   }
   
       public static void main(String[] args) throws InterruptedException {
           AddThread addThread = new AddThread();
           addThread.start();
           //调用join方法，即让main线程处于等待(wait)状态，直到调用线程执行完毕方可继续执行
           addThread.join(99); //当end - start > 这个值时，可以看到i的值并非10000000
           System.out.println(i);
       }
   }
   ```

2. yield：使当前线程让出cpu，当前线程在让出cpu后，还会进行cpu资源的争夺

   ```java
   public class Solution {
       public volatile static int i = 0;
       public static class AddThread extends Thread{
       @Override
       public void run() {
           Long start = System.currentTimeMillis();
           for (i=0;i<10000000;i++);
           Long end = System.currentTimeMillis();
           System.out.println(end - start);
       }
   }
   
       public static void main(String[] args) throws InterruptedException {
           AddThread addThread = new AddThread();
           addThread.start();
           //调用yield方法，即让main线程放弃cpu，但调用线程还没有执行完毕就又抢回CPU，导致并未执行完毕
           addThread.yield(); 
           System.out.println(i);
       }
   }
   ```

### 线程组

将具有相同功能的线程放置在一个线程组里

```java
public class ThreadGroupName implements Runnable{
    public static void main(String[] args) {
        ThreadGroup tg = new ThreadGroup("PrintGroup");
        Thread t1 = new Thread(tg,new ThreadGroupName(),"T1");
        Thread t2 = new Thread(tg,new ThreadGroupName(),"T2");
        t1.start();
        t2.start();
        System.out.println(tg.activeCount()); //获得活动线程的总数
        tg.list();//打印这个线程组中所有的线程信息
    }

    @Override
    public void run() {
        String groupAndName = Thread.currentThread().getThreadGroup().getName() +"-"+ Thread.currentThread().getName();
        while (true) {
            System.out.println("I am " + groupAndName);
            try{
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

### 守护线程

系统的守护者，在后台默默地完成一些系统性的服务，比如垃圾回收线程，JIT线程就可以理解为守护线程，与之相对应的是用户线程，用户线程可以认为是系统的工作线程，它会

